<!DOCTYPE html>
<html lang="ru" data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22ru%22%7D%7D">
<head >
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
  <meta name="referrer" content="unsafe-url">
  <title>Анатомия каналов в Go / Хабр</title>
  <style>
    /* cyrillic-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSxf6TF0.woff2) format('woff2');
      unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
    }

    /* cyrillic */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveQhf6TF0.woff2) format('woff2');
      unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
    }

    /* latin-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSBf6TF0.woff2) format('woff2');
      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
    }

    /* latin */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveRhf6.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }

    /* non-breaking hyphen */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/l/font?kit=KFOlCnqEu92Fr1MmEU9vBh0_IsHAlmrO6g&skey=ee881451c540fdec&v=v29) format('woff2');
      unicode-range: U+02011;
    }
  </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.4beb3834.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.59c14c8d.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/app.2eccdc41.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/app.af68bd55.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.4beb3834.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.2eccdc41.css">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.730d31a560e8dd9bdd985d4a4212822b.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  
  <script data-vue-meta="ssr" type="application/ld+json" data-vmid="ldjson-schema">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/post\/490336\/"},"headline":"Анатомия каналов в Go","datePublished":"2020-02-28T11:28:02+03:00","dateModified":"2020-03-03T16:35:41+03:00","author":{"@type":"Person","name":"Алексей"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"Привет, Хабр! Представляю вашему вниманию перевод статьи &quot;Anatomy of Channels in Go&quot; автора Uday Hiwarale. Что такое каналы? Канал &mdash; это объект связи, с помощью...","url":"https:\/\/habr.com\/ru\/post\/490336\/#post-content-body","about":["h_go","f_develop"],"image":["https:\/\/habr.com\/share\/publication\/490336\/c3baa6d7e4776d1acd4196a4a9814462\/"]}</script>
  <script src="//www.googletagservices.com/tag/js/gpt.js" async></script>
  <style>.grecaptcha-badge{visibility: hidden;}</style>
  <meta name="habr-version" content="2.73.0">
  
  <meta data-vue-meta="ssr" property="fb:app_id" content="444736788986613"><meta data-vue-meta="ssr" property="fb:pages" content="472597926099084"><meta data-vue-meta="ssr" name="twitter:card" content="summary_large_image"><meta data-vue-meta="ssr" name="twitter:site" content="@habr_com"><meta data-vue-meta="ssr" property="og:site_name" content="Хабр" data-vmid="og:site_name"><meta data-vue-meta="ssr" property="og:title" content="Анатомия каналов в Go" data-vmid="og:title"><meta data-vue-meta="ssr" name="twitter:title" content="Анатомия каналов в Go" data-vmid="twitter:title"><meta data-vue-meta="ssr" name="aiturec:title" content="Анатомия каналов в Go" data-vmid="aiturec:title"><meta data-vue-meta="ssr" name="description" content="Привет, Хабр! Представляю вашему вниманию перевод статьи &amp;quot;Anatomy of Channels in Go&amp;quot; автора Uday Hiwarale.
Что такое каналы?
Канал — это объект связи, с помощью которого горутины..." data-vmid="description"><meta data-vue-meta="ssr" itemprop="description" content="Привет, Хабр! Представляю вашему вниманию перевод статьи &amp;quot;Anatomy of Channels in Go&amp;quot; автора Uday Hiwarale.
Что такое каналы?
Канал — это объект связи, с помощью которого горутины..." data-vmid="description:itemprop"><meta data-vue-meta="ssr" property="og:description" content="Привет, Хабр! Представляю вашему вниманию перевод статьи &amp;quot;Anatomy of Channels in Go&amp;quot; автора Uday Hiwarale.
Что такое каналы?
Канал — это объект связи, с помощью которого горутины..." data-vmid="og:description"><meta data-vue-meta="ssr" name="twitter:description" content="Привет, Хабр! Представляю вашему вниманию перевод статьи &amp;quot;Anatomy of Channels in Go&amp;quot; автора Uday Hiwarale.
Что такое каналы?
Канал — это объект связи, с помощью которого горутины..." data-vmid="twitter:description"><meta data-vue-meta="ssr" property="aiturec:description" content="Привет, Хабр! Представляю вашему вниманию перевод статьи &amp;quot;Anatomy of Channels in Go&amp;quot; автора Uday Hiwarale.
Что такое каналы?
Канал — это объект связи, с помощью которого горутины..." data-vmid="aiturec:description"><meta data-vue-meta="ssr" itemprop="image" content="https://habr.com/share/publication/490336/c3baa6d7e4776d1acd4196a4a9814462/" data-vmid="image:itemprop"><meta data-vue-meta="ssr" property="og:image" content="https://habr.com/share/publication/490336/c3baa6d7e4776d1acd4196a4a9814462/" data-vmid="og:image"><meta data-vue-meta="ssr" property="og:image:width" content="1200" data-vmid="og:image:width"><meta data-vue-meta="ssr" property="og:image:height" content="630" data-vmid="og:image:height"><meta data-vue-meta="ssr" property="aiturec:image" content="https://habr.com/share/publication/490336/c3baa6d7e4776d1acd4196a4a9814462/" data-vmid="aiturec:image"><meta data-vue-meta="ssr" name="twitter:image" content="https://habr.com/share/publication/490336/c3baa6d7e4776d1acd4196a4a9814462/" data-vmid="twitter:image"><meta data-vue-meta="ssr" property="vk:image" content="https://habr.com/share/publication/490336/c3baa6d7e4776d1acd4196a4a9814462/?format=vk" data-vmid="vk:image"><meta data-vue-meta="ssr" property="aiturec:item_id" content="490336" data-vmid="aiturec:item_id"><meta data-vue-meta="ssr" property="aiturec:datetime" content="2020-02-28T08:28:02.000Z" data-vmid="aiturec:datetime"><meta data-vue-meta="ssr" content="https://habr.com/ru/post/490336/" property="og:url" data-vmid="og:url"><meta data-vue-meta="ssr" property="og:type" content="article" data-vmid="og:type"><meta data-vue-meta="ssr" property="og:locale" content="ru_RU" data-vmid="og:locale"><meta data-vue-meta="ssr" name="keywords" content="golang">
  <link data-vue-meta="ssr" href="https://habr.com/ru/rss/post/490336/?fl=ru" type="application/rss+xml" title="" rel="alternate" name="rss"><link data-vue-meta="ssr" href="https://habr.com/ru/post/490336/" rel="canonical" data-vmid="canonical"><link data-vue-meta="ssr" data-vmid="hreflang"><link data-vue-meta="ssr" image_src="image" href="https://habr.com/share/publication/490336/c3baa6d7e4776d1acd4196a4a9814462/" data-vmid="image:href">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="16x16"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png"
  >
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="32x32"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="76x76"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="120x120"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="152x152"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="180x180"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="256x256"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png"
  >
  <link
    rel="mask-icon"
    color="#77a2b6"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg"
  >
  <link
    crossorigin="use-credentials"
    href="/manifest.webmanifest"
    rel="manifest"
  >
  <script>window.yaContextCb = window.yaContextCb || []</script>
  <script src="https://yandex.ru/ads/system/context.js" async></script>
</head>
<body>


<div id="app" data-server-rendered="true" data-async-called="true"><div class="tm-layout__wrapper"><!----> <div></div> <!----> <header class="tm-header"><div class="tm-page-width"><div class="tm-header__container"><!----> <span class="tm-header__logo-wrap"><a href="/ru/" class="tm-header__logo tm-header__logo_ru"><svg height="16" width="16" class="tm-svg-img tm-header__icon"><title>Хабр</title> <use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a> <span class="tm-header__beta-sign" style="display:none;">β</span></span> <div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title> <use xlink:href="/img/megazord-v25.29545111.svg#arrow-down"></use></svg></button></div> <!----></div> <a href="/ru/sandbox/start/" class="tm-header__become-author-btn">
            Как стать автором
          </a> <div class="tm-feature tm-header__feature tm-feature tm-feature_variant-inline"><!----></div> <!----> <!----></div></div></header> <div class="tm-layout"><div class="tm-page-progress-bar"></div> <div data-menu-sticky="true" class="tm-base-layout__header tm-base-layout__header_is-sticky"><div class="tm-page-width"><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!----> <a href="/ru/all/" class="tm-main-menu__item">
        Все потоки
      </a> <a href="/ru/flows/develop/" class="tm-main-menu__item">
          Разработка
        </a><a href="/ru/flows/admin/" class="tm-main-menu__item">
          Администрирование
        </a><a href="/ru/flows/design/" class="tm-main-menu__item">
          Дизайн
        </a><a href="/ru/flows/management/" class="tm-main-menu__item">
          Менеджмент
        </a><a href="/ru/flows/marketing/" class="tm-main-menu__item">
          Маркетинг
        </a><a href="/ru/flows/popsci/" class="tm-main-menu__item">
          Научпоп
        </a></nav></div></div> <div class="tm-header-user-menu tm-base-layout__user-menu"><a href="/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search"><svg height="24" width="24" class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark"><title>Поиск</title> <use xlink:href="/img/megazord-v25.29545111.svg#search"></use></svg></a> <!----> <!----> <!----> <div class="tm-header-user-menu__item tm-header-user-menu__user_desktop"><div class="tm-dropdown"><div class="tm-dropdown__head"><svg height="24" width="24" data-test-id="menu-toggle-guest" class="tm-svg-img tm-header-user-menu__icon"><title>Профиль</title> <use xlink:href="/img/megazord-v25.29545111.svg#header-user"></use></svg> <!----></div> <!----></div> <!----></div> <!----></div></div></div></div> <!----> <div class="tm-page-width"></div> <main class="tm-layout__container"><div hl="ru" data-async-called="true" class="tm-page"><div class="tm-page-width"><!----> <div class="tm-page__wrapper"><div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down"><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg height="24" width="24" class="tm-svg-img pull-down__arrow"><title>Обновить</title> <use xlink:href="/img/megazord-v25.29545111.svg#pull-arrow"></use></svg></div></div> <div class="tm-article-presenter"> <div class="tm-article-presenter__body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><div class="tm-article-presenter__header"> <div class="tm-article-snippet tm-article-presenter__snippet"><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a href="/ru/users/alex89v/" title="alex89v" class="tm-user-info__userpic"><div class="tm-entity-image"><svg height="24" width="24" class="tm-svg-img tm-image-placeholder tm-image-placeholder_pink"><!----> <use xlink:href="/img/megazord-v25.29545111.svg#placeholder-user"></use></svg></div></a> <span class="tm-user-info__user"><a href="/ru/users/alex89v/" class="tm-user-info__username">
      alex89v
    </a> </span></span> <span class="tm-article-snippet__datetime-published"><time datetime="2020-02-28T08:28:02.000Z" title="2020-02-28, 11:28">28  февраля  2020 в 11:28</time></span></div> <!----></div> <h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1"><span>Анатомия каналов в Go</span></h1> <div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/go/" class="tm-article-snippet__hubs-item-link"><span>Go</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span></div> <div class="tm-article-snippet__labels"><div class="tm-article-snippet__label tm-article-snippet__label tm-article-snippet__label_variant-sandbox"><span>
        Из песочницы
      </span></div></div> <!----> <!----></div></div> <!----> <div data-gallery-root="" lang="ru" class="tm-article-body"><div></div> <div id="post-content-body"><div><div class="article-formatted-body article-formatted-body article-formatted-body_version-1"><div xmlns="http://www.w3.org/1999/xhtml"><p>Привет, Хабр! Представляю вашему вниманию перевод статьи <a href="https://medium.com/rungo/anatomy-of-channels-in-go-concurrency-in-go-1ec336086adb" rel="nofollow">"Anatomy of Channels in Go"</a> автора Uday Hiwarale.</p><br/>
<h2 id="chto-takoe-kanaly">Что такое каналы?</h2><br/>
<p>Канал — это объект связи, с помощью которого горутины обмениваются данными. Технически это конвейер (или труба), откуда можно считывать или помещать данные. То есть одна горутина может отправить данные в канал, а другая — считать помещенные в этот канал данные.</p><br/>
<h2 id="sozdanie-kanala">Создание канала</h2><br/>
<p>Go для создания канала предоставляет ключевое слово chan. Канал может передавать данные только одного типа, данные других типов через это канал передавать невозможно.</p><a name="habracut"></a><br/>
<pre><code class="go">package main

import "fmt"

func main() {
    var c chan int
    fmt.Println(c)
} </code></pre><br/>
<p><a href="https://play.golang.org/p/iWOFLfcgfF-" rel="nofollow">Пример в play.golang.org</a></p><br/>
<p>Программа выше создает канал <code>c</code>, который будет передавать <code>int</code>. Данная программа выведет <code>&lt;nil></code>, потому что нулевое значение канала — это <code>nil</code>. Такой канал абсолютно бесполезен. Вы не можете передать или получить данные из канала, так как он не был создан (инициализирован). Для его создания необходимо использовать <code>make</code>. </p><br/>
<pre><code class="go">package main

import "fmt"

func main() {
    c := make(chan int)

    fmt.Printf("type of `c` is %T\n", c)
    fmt.Printf("value of `c` is %v\n", c)
}</code></pre><br/>
<p><a href="https://play.golang.org/p/N4dU7Ql9bK7" rel="nofollow">Пример в play.golang.org</a></p><br/>
<p>В данном примере используется короткий синтаксис <code>:=</code> для создания канала с использованием функции <code>make</code>. Программа выше выводит следующий результат:</p><br/>
<pre><code class="plaintext">type of `c` is chan int
value of `c` is 0xc0420160c0</code></pre><br/>
<p>Обратите внимание на значение переменной <code>c</code>, это адрес в памяти. В go каналы являются указателями. В большинстве своем, когда вам необходимо взаимодействовать с горутиной, вы помещаете канал как аргумент в функцию или метод. Горутина получает этот канал как аргумент, и вам не нужно разыменовывать его для того, чтобы извлечь или передать данные через этот канал.</p><br/>
<h2 id="zapis-i-chtenie-dannyh">Запись и чтение данных</h2><br/>
<p>Go предоставляет простой синтаксис для чтения <code>&lt;-</code> и записи в канал</p><br/>
<pre><code class="plaintext">c &lt;- data</code></pre><br/>
<p>В этом примере мы передаем данные в канал <code>c</code>. Направление стрелки указывает на то, что мы извлекаем данные из <code>data</code> и помещаем в канал <code>c</code>.</p><br/>
<pre><code class="plaintext">&lt;- c</code></pre><br/>
<p>А здесь мы считываем данные с канала <code>c</code>. Эта операция не сохраняет данные в переменную и она является корректной. Если вам необходимо сохранить данные с канала в переменную, вы можете использовать следующий синтаксис:</p><br/>
<pre><code class="plaintext">var data int
data = &lt;- c</code></pre><br/>
<p>Теперь данные из канала <code>c</code>, который имеет тип <code>int</code>, могут быть записаны в переменную <code>data</code>. Так же можно упростить запись, используя короткий синтаксис:</p><br/>
<pre><code class="plaintext">data := &lt;- c</code></pre><br/>
<p>Go определит тип данных, передаваемый каналу <code>c</code>, и предоставит <code>data</code> корректный тип данных.</p><br/>
<p>Все вышеобозначенные операции с каналом являются блокируемыми. Когда вы помещаете данные в канал, горутина блокируется до тех пор, пока данные не будут считаны другой горутиной из этого канала. В то же время операции канала говорят планировщику о планировании другой горутины, поэтому программа не будет заблокирована полностью. Эти функции весьма полезны, так как отпадает необходимость писать блокировки для взаимодействия горутин.</p><br/>
<h2 id="kanaly-na-praktike">Каналы на практике</h2><br/>
<pre><code class="go">package main

import "fmt"

func greet(c chan string) {
    fmt.Println("Hello " + &lt;-c + "!")
}

func main() {
    fmt.Println("main() started")
    c := make(chan string)

    go greet(c)

    c &lt;- "John"
    fmt.Println("main() stopped")
}</code></pre><br/>
<p><a href="https://play.golang.org/p/OeYLKEz7qKi" rel="nofollow">Пример в play.golang.org</a></p><br/>
<p>Разберем программу по шагам:</p><br/>
<ol>
<li>Мы объявили функцию <code>greet</code>, которая принимает канал <code>c</code> как аргумент. В этой функции мы считываем данные из канала <code>c</code> и выводим в консоль.</li>
<li>В функции <code>main</code> программа сначала выводит <code>"main() started"</code>.</li>
<li>Затем мы, используя <code>make</code>, создаем канал <code>c</code> с типом даных <code>string</code>.</li>
<li>Помещаем канал <code>с</code> в функцию <code>greet</code> и запускаем функцию как горутину, используя ключевое слово <code>go</code>.</li>
<li>Теперь у нас имеется две горутины <code>main</code> и <code>greet</code>, <code>main</code> по-прежнему остается активной.</li>
<li>Помещаем данные в канал <code>с</code> и в этот момент <code>main</code> блокируется до тех пор, пока другая горутина (<code>greet</code>) не считает данные из канала <code>c</code>. Планировщик Go планирует запуск <code>greet</code> и выполняет описанное в первом пункте.</li>
<li>После чего <code>main</code> снова становится активной и выводит в консоль <code>"main() stopped"</code>.</li>
</ol><br/>
<h2 id="deadlock-vzaimnaya-blokirovka">Deadlock (Взаимная блокировка)</h2><br/>
<p>Как уже ранее говорилось, чтение или запись данных в канал блокирует горутину и контроль передается свободной горутине. Представим, что такие горутины отсутствуют, либо они все "спят". В этот момент возникает deadlock, который приведет к аварийному завершению программы.</p><br/>
<blockquote>Если вы попытаетесь считать данные из канала, но в канале будут отсутствовать данные, планировщик заблокирует текущую горутину и разблокирует другую в надежде, что какая-либо горутина передаст данные в канал. То же самое произойдет в случае отправки данных: планировщик заблокирует передающую горутину, пока другая не считает данные из канала.</blockquote><p>Примером deadlock может быть <code>main</code> горутина, которая эксклюзивно производит операции с каналом.</p><br/>
<pre><code class="go">package main

import "fmt"

func main() {
    fmt.Println("main() started")

    c := make(chan string)
    c &lt;- "John"

    fmt.Println("main() stopped")
}</code></pre><br/>
<p><a href="https://play.golang.org/p/2KTEoljdci_f" rel="nofollow">Пример в play.golang.org</a></p><br/>
<p>Программа выше выведет следующее при попытке ее исполнить:</p><br/>
<pre><code class="plaintext">main() started
fatal error: all goroutines are asleep - deadlock!
goroutine 1 [chan send]:
main.main()
        program.go:10 +0xfd
exit status 2</code></pre><br/>
<h3 id="zakrytie-kanala">Закрытие канала</h3><br/>
<p>В Go так же можно закрыть канал, через закрытый канал невозможно будет передать или принять данные. Горутина может проверить закрыт канал или нет, используя следующую конструкцию: <code>val, ok := &lt;- channel</code>, где ok будет истиной в случае, если канал открыт или операция чтения может быть выполнена, иначе <code>ok</code> будет <code>false</code>, если канал закрыт и отсутствуют данных для чтения из него. Закрыть канал можно, используя встроенную функцию <code>close</code>, используя следующий синтаксис <code>close(channel)</code>. Давайте рассмотрим следующий пример:</p><br/>
<pre><code class="go">package main

import "fmt"

func greet(c chan string) {
    &lt;-c // for John
    &lt;-c // for Mike
}

func main() {
    fmt.Println("main() started")

    c := make(chan string, 1)

    go greet(c)
    c &lt;- "John"

    close(c) // closing channel

    c &lt;- "Mike"
    fmt.Println("main() stopped")
}</code></pre><br/>
<p><a href="https://play.golang.org/p/LMmAq4sgm02" rel="nofollow">Пример в play.golang.org</a></p><br/>
<blockquote>Для понимания концепта блокировки первая операция отправки <code>c &lt;- "John"</code> будет блокирующей, и другая горутина должна будет считать данные из канала, следовательно <code>greet</code> горутина будет запланирована планировщиком. Затем первая операция чтения будет неблокируемой, поскольку присутствуют данные для чтения в канале <code>c</code>. Вторая операция чтения будет блокируемой, потому что в канале <code>c</code> отсутствуют данные, поэтому планировщик переключится на <code>main</code> горутину и программа выполнит закрытие канала <code>close(c)</code>.</blockquote><p>Вывод программы:</p><br/>
<pre><code class="plaintext">main() started
panic: send on closed channel

goroutine 1 [running]:
main.main()
    program.go:20 +0x120
exit status 2</code></pre><br/>
<p>Как вы можете заметить, программа завершилась с ошибкой, которая говорит, что запись в закрытый канал невозможна. Для дальнейшего понимания закрытия каналов давайте рассмотрим пример с циклом <code>for</code>.</p><br/>
<h3 id="primer-s-ciklom-for">Пример с циклом for</h3><br/>
<pre><code class="go">package main

import "fmt"

func squares(c chan int) {
    for i := 0; i &lt;= 9; i++ {
        c &lt;- i * i
    }

    close(c) // close channel
}

func main() {
    fmt.Println("main() started")
    c := make(chan int)

    go squares(c) // start goroutine

    // periodic block/unblock of main goroutine until chanel closes
    for {
        val, ok := &lt;-c
        if ok == false {
            fmt.Println(val, ok, "&lt;-- loop broke!")
            break // exit break loop
        } else {
            fmt.Println(val, ok)
        }
    }

    fmt.Println("main() stopped")
}</code></pre><br/>
<p><a href="https://play.golang.org/p/X58FTgSHhXi" rel="nofollow">Пример в play.golang.org</a></p><br/>
<p>Бесконечный цикл может быть полезен для чтения данных из канала, когда мы не знаем сколько данных мы ожидаем. В этом примере мы создаем горутину <code>squares</code>, которая последовательно возвращает квадраты чисел от 0 до 9. В <code>main</code> мы считываем эти числа внутри цикла <code>for</code>.</p><br/>
<p>В цикле мы считываем данные из канала, используя ранее рассмотренный синтаксис <code>val, ok := &lt;-c</code>, где <code>ok</code> предоставляет нам информацию о том, что канал закрыт. В горутине <code>squares</code> после того, как записали все данные, мы закрываем канал, используя функцию <code>close</code>. Когда <code>ok</code> будет <code>true</code>, программа выведет значение <code>val</code> и статус канала (переменная <code>ok</code>). Когда <code>ok</code> станет <code>false</code>, мы завершим цикл, используя ключевое слово <code>break</code>. Таким образом мы получим следующий результат:</p><br/>
<pre><code class="plaintext">main() started
0 true
1 true
4 true
9 true
16 true
25 true
36 true
49 true
64 true
81 true
0 false &lt;-- loop broke!
main() stopped</code></pre><br/>
<blockquote>Когда канал закрыт, значение <code>val</code>, считанное горутиной, является нулевым значением, в зависимости от типа данных канала. Так как в нашем случае тип данных канала <code>int</code>, то нулевое значение будет 0, как раз это мы и видим в этой строке: <code>0 false &lt;-- loop broke!</code></blockquote><p>Для того, чтобы избежать столь громоздкой проверки закрытия канала в случае цикла <code>for</code>, Go предоставляет ключевое слово <code>range</code>, которое автоматически останавливает цикл, когда канал будет закрыт. Давайте перепишем нашу программу с использованием <code>range</code>:</p><br/>
<pre><code class="go">package main

import "fmt"

func squares(c chan int) {
    for i := 0; i &lt;= 9; i++ {
        c &lt;- i * i
    }

    close(c) // close channel
}

func main() {
    fmt.Println("main() started")
    c := make(chan int)

    go squares(c) // start goroutine

    // periodic block/unblock of main goroutine until chanel closes
    for val := range c {
        fmt.Println(val)
    }

    fmt.Println("main() stopped")
}</code></pre><br/>
<p><a href="https://play.golang.org/p/ICCYbWO7ZvD" rel="nofollow">Пример в play.golang.org</a></p><br/>
<p>В этом примере мы использовали <code>val := range c</code> вместо бесконечного цикла, где <code>range</code> будет считывать данные из канала до тех пор, пока канал не будет закрыт. В результате программа выведет следующее:</p><br/>
<pre><code class="plaintext">main() started
0
1
4
9
16
25
36
49
64
81
main() stopped</code></pre><br/>
<blockquote>Если вы не закроете канал для цикла <code>for</code> с использованием <code>range</code>, то программа будет завершена аварийно из-за <code>dealock</code> во время выполнения.</blockquote><br/>
<h3 id="razmer-bufera-kanala">Размер буфера канала</h3><br/>
<p>Как вы уже заметили, каждая операция отправки данных в канал блокирует текущую горутину. Но мы еще не использовали функцию <code>make</code> с 2-мя аргументами. Второй аргумент — это размер буфера канала. По-умолчанию размер буфера канала равен 0, такой канал называется небуферизированным каналом. То есть все, что мы пишем в канал, сразу доступно для чтения.</p><br/>
<p>Когда размер буфера больше 0, горутина не блокируется до тех пор, пока буфер не будет заполнен. Когда буфер заполнен, любые значения отправляемые через канал, добавляются к буферу, отбрасывая предыдущее значение, которое доступно для чтения (где горутина будет заблокирована). Но есть один подвох, операция чтения на буферизированном канале является жадной, таким образом, как только операция чтения началась, она не будет завершена до полного опустошения буфера. Это означает, что горутина будет считывать буфер канала без блокировки до тех пор, пока буфер не станет пустым.</p><br/>
<p>Для объявления буферизированного канала мы можем использовать следующий синтаксис:</p><br/>
<pre><code class="plaintext">c := make(chan Type, n)</code></pre><br/>
<p>Это выражение создаст канал с типом данных <code>Type</code> и размером буфера <code>n</code>. Текущая горутина не будет заблокирована, пока в канал не будет передано n+1 данных.</p><br/>
<p>Давайте докажем, что горутина не блокируется, пока буфер не заполнится и не переполнится:</p><br/>
<pre><code class="go">package main

import "fmt"

func squares(c chan int) {
    for i := 0; i &lt;= 3; i++ {
        num := &lt;-c
        fmt.Println(num * num)
    }
}

func main() {
    fmt.Println("main() started")
    c := make(chan int, 3)

    go squares(c)

    c &lt;- 1
    c &lt;- 2
    c &lt;- 3

    fmt.Println("main() stopped")
}</code></pre><br/>
<p><a href="https://play.golang.org/p/k0usdYZfp3D" rel="nofollow">Пример в play.golang.org</a></p><br/>
<p>В этом примере канал <code>c</code> имеет размер буфера равным 3. Это означает, что он может содержать 3 значения(<code>c &lt;- 3</code>), но поскольку буфер не переполняется (так как мы не поместили новое значение в буфер), <code>main</code> не будет блокироваться, и программа будет успешно завершена без вывода чисел. Вывод программы:</p><br/>
<pre><code class="plaintext">main() started
main() stopped</code></pre><br/>
<p>Теперь давайте поместим еще одно значение в канал:</p><br/>
<pre><code class="go">package main

import "fmt"

func squares(c chan int) {
    for i := 0; i &lt;= 3; i++ {
        num := &lt;-c
        fmt.Println(num * num)
    }
}

func main() {
    fmt.Println("main() started")
    c := make(chan int, 3)

    go squares(c)

    c &lt;- 1
    c &lt;- 2
    c &lt;- 3
    c &lt;- 4 // blocks here

    fmt.Println("main() stopped")
}</code></pre><br/>
<p><a href="https://play.golang.org/p/KGyiskRj1Wi" rel="nofollow">Пример в play.golang.org</a></p><br/>
<p>Как упоминалось ранее, теперь мы помещаем дополнительное значение в буфер и <code>main</code> блокируется, затем стартует горутина <code>squares</code>, которая вычитывает все значения из буфера, пока он не станет пустым.</p><br/>
<h2 id="dlina-i-emkost-kanala">Длина и емкость канала</h2><br/>
<p>Подобно срезам, буферизированный канал имеет длину и емкость. Длина канала — это количество значений в очереди (не считанных) в буфере канала, емкость — это размер самого буфера канала. Для того, чтобы вычислить длину, мы используем функцию <code>len</code>, а, используя функцию <code>cap</code>, получаем размер буфера.</p><br/>
<pre><code class="plaintext">package main

import "fmt"

func main() {
    c := make(chan int, 3)
    c &lt;- 1
    c &lt;- 2

    fmt.Printf("Length of channel c is %v and capacity of channel c is %v", len(c), cap(c))
    fmt.Println()
}
</code></pre><br/>
<p><a href="https://play.golang.org/p/qsDZu6pXLT7" rel="nofollow">Пример в play.golang.org</a></p><br/>
<p>Вывод программы:</p><br/>
<pre><code class="plaintext">Length of channel c is 2 and capacity of channel c is 3</code></pre><br/>
<p>Вышеприведенная программа работает нормально и <code>deadlock</code> не возникает, потому что размер буфера канала равен 3, а мы записали только 2 значения в буфер, поэтому планировщик не попытался запланировать другую горутину и не заблокировал <code>main</code>. Вы даже можете считать эти данные в <code>main</code>, если вам это необходимо, потому что <strong>буфер не заполнен</strong>.</p><br/>
<p>Другой пример:</p><br/>
<pre><code class="go">package main

import "fmt"

func sender(c chan int) {
    c &lt;- 1 // len 1, cap 3
    c &lt;- 2 // len 2, cap 3
    c &lt;- 3 // len 3, cap 3
    c &lt;- 4 // &lt;- goroutine blocks here
    close(c)
}

func main() {
    c := make(chan int, 3)

    go sender(c)

    fmt.Printf("Length of channel c is %v and capacity of channel c is %v\n", len(c), cap(c))

    // read values from c (blocked here)
    for val := range c {
        fmt.Printf("Length of channel c after value '%v' read is %v\n", val, len(c))
    }
}</code></pre><br/>
<p><a href="https://play.golang.org/p/-gGpm08-wzz" rel="nofollow">Пример в play.golang.org</a></p><br/>
<p>Вывод программы:</p><br/>
<pre><code class="plaintext">Length of channel c is 0 and capacity of channel c is 3
Length of channel c after value '1' read is 3
Length of channel c after value '2' read is 2
Length of channel c after value '3' read is 1
Length of channel c after value '4' read is 0</code></pre><br/>
<p>Дополнительный пример с буферизированным каналом:</p><br/>
<pre><code class="go">package main

import (
    "fmt"
    "runtime"
)

func squares(c chan int) {
    for i := 0; i &lt; 4; i++ {
        num := &lt;-c
        fmt.Println(num * num)
    }
}

func main() {
    fmt.Println("main() started")
    c := make(chan int, 3)
    go squares(c)

    fmt.Println("active goroutines", runtime.NumGoroutine())
    c &lt;- 1
    c &lt;- 2
    c &lt;- 3
    c &lt;- 4 // blocks here

    fmt.Println("active goroutines", runtime.NumGoroutine())

    go squares(c)

    fmt.Println("active goroutines", runtime.NumGoroutine())

    c &lt;- 5
    c &lt;- 6
    c &lt;- 7
    c &lt;- 8 // blocks here

    fmt.Println("active goroutines", runtime.NumGoroutine())
    fmt.Println("main() stopped")
}
</code></pre><br/>
<p><a href="https://play.golang.org/p/sdHPDx64aor" rel="nofollow">Пример в play.golang.org</a></p><br/>
<p>Вывод программы:</p><br/>
<pre><code class="plaintext">main() started
active goroutines 2
1
4
9
16
active goroutines 1
active goroutines 2
25
36
49
64
active goroutines 1
main() stopped
</code></pre><br/>
<p>Используя буферизованный канал и цикл <code>for range</code>, мы можем читать с закрытых каналов. Поскольку у закрытых каналов данные все еще живут в буфере, их можно считать:</p><br/>
<pre><code class="go">package main

import "fmt"

func main() {
    c := make(chan int, 3)
    c &lt;- 1
    c &lt;- 2
    c &lt;- 3
    close(c)

    // iteration terminates after receiving 3 values
    for elem := range c {
        fmt.Println(elem)
    }
}</code></pre><br/>
<p><a href="https://play.golang.org/p/vULFyWnpUoj" rel="nofollow">Пример в play.golang.org</a></p><br/>
<h2 id="rabota-s-neskolkimi-gorutinami">Работа с несколькими горутинами</h2><br/>
<p>Давайте напишем 2 горутины, одна для вычисления квадрата целого числа, а другая для вычисления куба:</p><br/>
<pre><code class="go">package main

import "fmt"

func square(c chan int) {
    fmt.Println("[square] reading")
    num := &lt;-c
    c &lt;- num * num
}

func cube(c chan int) {
    fmt.Println("[cube] reading")
    num := &lt;-c
    c &lt;- num * num * num
}

func main() {
    fmt.Println("[main] main() started")

    squareChan := make(chan int)
    cubeChan := make(chan int)

    go square(squareChan)
    go cube(cubeChan)

    testNum := 3
    fmt.Println("[main] sent testNum to squareChan")

    squareChan &lt;- testNum

    fmt.Println("[main] resuming")
    fmt.Println("[main] sent testNum to cubeChan")

    cubeChan &lt;- testNum

    fmt.Println("[main] resuming")
    fmt.Println("[main] reading from channels")

    squareVal, cubeVal := &lt;-squareChan, &lt;-cubeChan
    sum := squareVal + cubeVal

    fmt.Println("[main] sum of square and cube of", testNum, " is", sum)
    fmt.Println("[main] main() stopped")
}</code></pre><br/>
<p><a href="https://play.golang.org/p/6wdhWYpRfrX" rel="nofollow">Пример в play.golang.org</a></p><br/>
<p>Разберем программу по шагам:</p><br/>
<ol>
<li>Мы создали 2 функции <code>square</code> и <code>cube</code>, которые мы запускаем как горутины. Обе получают канал <code>c</code> c типом данных <code>int</code>, и считывают данные из него в переменную <code>num</code>. Затем мы пишем данные в канал <code>c</code>.</li>
<li>В <code>main</code> горутине мы создаем два канала <code>squareChan</code> и <code>cubeChan</code> c типом данных <code>int</code>.</li>
<li>Запускаем <code>square</code> и <code>cube</code> горутины.</li>
<li>Так как контроль по-прежнему внутри <code>main</code> <code>testNum</code> получает значение 3.</li>
<li>Затем мы отправляем данные в канал <code>squareChan</code> и <code>cubeChan</code>. Горутина <code>main</code> будет заблокирована, пока данные из каналов не будут считаны. Как только значение будет считано, горутина снова станет активной.</li>
<li>Когда в <code>main</code> мы попытаемся прочитать данные из заданных каналов(<code>squareChan</code> и <code>cubeChan</code>), управление будет заблокировано, пока другие горутины (<code>square</code> и <code>cube</code>) не запишут данные в эти каналы. Мы также использовали сокращенный синтаксис <code>:=</code> для получения данных из каналов.</li>
<li>Когда операция записи канала завершена, начинает выполняться <code>main</code>, после чего мы рассчитываем сумму и выводим ее.</li>
</ol><br/>
<p>Результат выполнения программы:</p><br/>
<pre><code class="plaintext">[main] main() started
[main] sent testNum to squareChan
[cube] reading
[square] reading
[main] resuming
[main] sent testNum to cubeChan
[main] resuming
[main] reading from channels
[main] sum of square and cube of 3  is 36
[main] main() stopped</code></pre><br/>
<h3 id="odnonapravlennye-kanaly">Однонаправленные каналы</h3><br/>
<p>До сих пор мы видели каналы, которые могут передавать и принимать данные. Но мы также можем создать канал, который будет однонаправленным. Например, канал, который сможет только считывать данные, и канал который сможет только записывать их.</p><br/>
<p>Однонаправленный канал также создается с использованием <code>make</code>, но с дополнительным стрелочным синтаксисом.</p><br/>
<pre><code class="plaintext">roc := make(&lt;-chan int)
soc := make(chan&lt;- int)</code></pre><br/>
<p>Где <code>roc</code> канал для чтения, а <code>soc</code> канал для записи. Следует заметить, что каналы также имеют разный тип.</p><br/>
<pre><code class="go">package main

import "fmt"

func main() {
    roc := make(&lt;-chan int)
    soc := make(chan&lt;- int)

    fmt.Printf("Data type of roc is `%T`\n", roc)
    fmt.Printf("Data type of soc is `%T\n", soc)
}
</code></pre><br/>
<p><a href="https://play.golang.org/p/JZO51IoaMg8" rel="nofollow">Пример в play.golang.org</a></p><br/>
<p>Вывод программы:</p><br/>
<pre><code class="plaintext">Data type of roc is `&lt;-chan int`
Data type of soc is `chan&lt;- int</code></pre><br/>
<p>Но в чем смысл использования однонаправленного канала? Использование однонаправленного канала улучшает безопасность типов в программe, что, как следствие, порождает меньше ошибок.</p><br/>
<p>Но допустим, что у вас есть программа, в которой вам нужно только читать данные из канала, а основная программа должна иметь возможность читать и записывать данные из/в тот же канал. Как это будет работать?</p><br/>
<p>К счастью Go предоставляет простой синтаксис для преобразования двунаправленного канала в однонаправленный канал.</p><br/>
<pre><code class="go">import "fmt"

func greet(roc &lt;-chan string) {
    fmt.Println("Hello " + &lt;-roc + "!")
}

func main() {
    fmt.Println("main() started")
    c := make(chan string)

    go greet(c)

    c &lt;- "John"
    fmt.Println("main() stopped")
}</code></pre><br/>
<p><a href="https://play.golang.org/p/k3B3gCelrGv" rel="nofollow">Пример в play.golang.org</a></p><br/>
<p>Мы только что изменили параметры <code>greet</code> для того, чтобы преобразовать двунаправленный канал на канал для чтения данных. Теперь мы можем только считывать данные из этого канала, а любые операции чтения приведут к аварийному завершению программы со следующей ошибкой:</p><br/>
<p><code>"invalid operation: roc &lt;- "some text" (send to receive-only type &lt;-chan string)"</code></p><br/>
<h3 id="anonimnye-gorutiny">Анонимные горутины</h3><br/>
<p>Каналы также могут работать и с анонимными горутинами. Давайте изменим предыдущий пример, используя анонимные горутины.<br/>
Вот что у нас получилось:</p><br/>
<pre><code class="go">package main

import "fmt"

func main() {
    fmt.Println("main() started")
    c := make(chan string)

    // launch anonymous goroutine
    go func(c chan string) {
        fmt.Println("Hello " + &lt;-c + "!")
    }(c)

    c &lt;- "John"
    fmt.Println("main() stopped")
}</code></pre><br/>
<p><a href="https://play.golang.org/p/cM5nFgRha7c" rel="nofollow">Пример в play.golang.org</a></p><br/>
<p>Как вы можете заметить вывод программы остался тот же самый.</p><br/>
<h3 id="kanal-s-tipom-dannyh-kanala">Канал с типом данных канала</h3><br/>
<p>Каналы являются <a href="https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82_%D0%BF%D0%B5%D1%80%D0%B2%D0%BE%D0%B3%D0%BE_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0" rel="nofollow">объектами первого класса</a>, то есть они могут быть использованы как значение элемента структуры, или аргументы функции, как возврат значения из функции/метода и даже как тип для другого канала. В примере ниже мы используем канал в качестве типа данных для другого канала:</p><br/>
<pre><code class="go">package main

import "fmt"

// gets a channel and prints the greeting by reading from channel
func greet(c chan string) {
    fmt.Println("Hello " + &lt;-c + "!")
}

// gets a channels and writes a channel to it
func greeter(cc chan chan string) {
    c := make(chan string)
    cc &lt;- c
}

func main() {
    fmt.Println("main() started")

    // make a channel `cc` of data type channel of string data type
    cc := make(chan chan string)

    go greeter(cc) // start `greeter` goroutine using `cc` channel

    // receive a channel `c` from `greeter` goroutine
    c := &lt;-cc

    go greet(c) // start `greet` goroutine using `c` channel

    // send data to `c` channel
    c &lt;- "John"

    fmt.Println("main() stopped")
}</code></pre><br/>
<p><a href="https://play.golang.org/p/xVQvvb8O4De" rel="nofollow">Пример в play.golang.org</a></p><br/>
<h3 id="select">select</h3><br/>
<p><code>select</code> похож на <code>switch</code> без аргументов, но он может использоваться только для операций с каналами. Оператор <code>select</code> используется для выполнения операции только с одним из множества каналов, условно выбранного блоком case.</p><br/>
<p>Давай взглянем на пример ниже, и обсудим как он работает:</p><br/>
<pre><code class="go">package main

import (
    "fmt"
    "time"
)

var start time.Time
func init() {
    start = time.Now()
}

func service1(c chan string) {
    time.Sleep(3 * time.Second)
    c &lt;- "Hello from service 1"
}

func service2(c chan string) {
    time.Sleep(5 * time.Second)
    c &lt;- "Hello from service 2"
}

func main() {
    fmt.Println("main() started", time.Since(start))

    chan1 := make(chan string)
    chan2 := make(chan string)

    go service1(chan1)
    go service2(chan2)

    select {
    case res := &lt;-chan1:
        fmt.Println("Response from service 1", res, time.Since(start))
    case res := &lt;-chan2:
        fmt.Println("Response from service 2", res, time.Since(start))
    }

    fmt.Println("main() stopped", time.Since(start))
}</code></pre><br/>
<p><a href="https://play.golang.org/p/ar5dZUQ2ArH" rel="nofollow">Пример в play.golang.org</a></p><br/>
<p>В этом примере мы используем оператор <code>select</code> как <code>switch</code>, но вместо булевых операций, мы используем операции для чтения данных из канала. Оператор <code>select</code> также является блокируемым, за исключением использования <code>default</code>(позже вы увидите пример с его использованием). После выполнения одного из блоков <code>case</code>, горутина <code>main</code> будет разблокирована. Задались вопросом когда <code>case</code> условие выполнится?</p><br/>
<p>Если все блоки <code>case</code> являются блокируемыми, тогда <code>select</code> будет ждать до момента, пока один из блоков <code>case</code> разблокируется и будет выполнен. Если несколько или все канальные операции не блокируемы, тогда один из неблокируемых <code>case</code> будет выбран случайным образом (Примечание переводчика: имеется ввиду случай, когда пришли одновременно данные из двух и более каналов).</p><br/>
<p>Давайте наконец разберем программу, которую написали ранее. Мы запустили 2 горутины с независимыми каналами. Затем мы использовали оператор <code>select</code> c двумя <code>case</code> операторами. Один <code>case</code> считывает данные из <code>chan1</code> а другой из <code>chan2</code>. Так как каналы не используют буфер, операция чтения будет блокируемой. Таким образом оба <code>case</code> будут блокируемыми и <code>select</code> будет ждать до тех пор, пока один из <code>case</code> не разблокируется.</p><br/>
<p>Когда программа находится в блоке <code>select</code> горутина <code>main</code> будет заблокирована и будут запланированы все горутины (по одной за раз), которые используются в блоке <code>select</code>, в нашем случае это <code>service1</code> и <code>service2</code>. <code>service1</code> ждет 3 секунды, после чего будет разблокирован и сможет записать данные в <code>chan1</code>. Таким же образом как и <code>service1</code> действует <code>service2</code>, только он ожидает 5 секунд и осуществляет запись в <code>chan2</code>. Так как <code>service1</code> разблокируется раньше, чем <code>service2</code>, первый <code>case</code> разблокируется раньше и произведет чтение из <code>chan1</code>, а второй <code>case</code> будет проигнорирован. После чего управление вернется в <code>main</code>, и программа завершится после вывода в консоль.</p><br/>
<p>Вывод программы:</p><br/>
<pre><code class="plaintext">main() started 0s
Response from service 1 Hello from service 1 3s
main() stopped 3s</code></pre><br/>
<blockquote>Вышеприведенная программа имитирует реальный веб-сервис, в котором балансировщик нагрузки получает миллионы запросов и должен возвращать ответ от одной из доступных служб. Используя стандартные горутины, каналы и select, мы можем запросить ответ у нескольких сервисов, и тот, который ответит раньше всех, может быть использован.</blockquote><p>Для того, чтобы симулировать случай, когда все блоки <code>case</code> разблокируются в одно и тоже время, мы может просто удалить вызов Sleep из горутин.</p><br/>
<pre><code class="go">package main

import (
    "fmt"
    "time"
)

var start time.Time
func init() {
    start = time.Now()
}

func service1(c chan string) {
    c &lt;- "Hello from service 1"
}

func service2(c chan string) {
    c &lt;- "Hello from service 2"
}

func main() {
    fmt.Println("main() started", time.Since(start))

    chan1 := make(chan string)
    chan2 := make(chan string)

    go service1(chan1)
    go service2(chan2)

    select {
    case res := &lt;-chan1:
        fmt.Println("Response from service 1", res, time.Since(start))
    case res := &lt;-chan2:
        fmt.Println("Response from service 2", res, time.Since(start))
    }

    fmt.Println("main() stopped", time.Since(start))
}</code></pre><br/>
<p><a href="https://play.golang.org/p/giSkkqt8XHb" rel="nofollow">Пример в play.golang.org</a></p><br/>
<p>Данная программа выводит следующий результат:</p><br/>
<pre><code class="plaintext">main() started 0s
service2() started 481µs
Response from service 2 Hello from service 2 981.1µs
main() stopped 981.1µs</code></pre><br/>
<p>Но иногда вы можете получить следующий результат:</p><br/>
<pre><code class="plaintext">main() started 0s
service1() started 484.8µs
Response from service 1 Hello from service 1 984µs
main() stopped 984µs</code></pre><br/>
<p>Это происходит потому, что операции <code>chan1</code> и <code>chan2</code> выполняются практически одновременно, но все же существует некоторая разница во времени при исполнении и планировании горутин.</p><br/>
<p>Для того, чтобы сделать все блоки <code>case</code> неблокируемыми, мы можем использовать каналы с буфером.</p><br/>
<pre><code class="go">package main

import (
    "fmt"
    "time"
)

var start time.Time

func init() {
    start = time.Now()
}

func main() {
    fmt.Println("main() started", time.Since(start))
    chan1 := make(chan string, 2)
    chan2 := make(chan string, 2)

    chan1 &lt;- "Value 1"
    chan1 &lt;- "Value 2"
    chan2 &lt;- "Value 1"
    chan2 &lt;- "Value 2"

    select {
    case res := &lt;-chan1:
        fmt.Println("Response from chan1", res, time.Since(start))
    case res := &lt;-chan2:
        fmt.Println("Response from chan2", res, time.Since(start))
    }

    fmt.Println("main() stopped", time.Since(start))
}</code></pre><br/>
<p><a href="https://play.golang.org/p/RLRGEmFQP3f" rel="nofollow">Пример в play.golang.org</a></p><br/>
<p>Вывод может быть следующим:</p><br/>
<pre><code class="plaintext">main() started 0s
Response from chan2 Value 1 0s
main() stopped 1.0012ms</code></pre><br/>
<p>Или таким:</p><br/>
<pre><code class="plaintext">main() started 0s
Response from chan1 Value 1 0s
main() stopped 1.0012ms</code></pre><br/>
<p>В приведенной программе оба канала имеют буфер размером 2. Так как мы отправляем 2 значения в буфер, горутина не будет заблокирована и программа перейдет в блок <code>select</code>. Чтение из буферизированного канала не является блокируемой операцией, если буфер не пустой, поэтому все блоки <code>case</code> будут неблокируемыми, и во время выполнения Go выберет <code>case</code> случайным образом.</p><br/>
<h3 id="default-case">default case</h3><br/>
<p>Так же как и <code>switch</code>, оператор <code>select</code> поддерживает оператор <code>default</code>. Оператор <code>default</code> является неблокируемым, но это еще не все, оператор <code>default</code> делает блок <code>select</code> всегда неблокируемым. Это означает, что операции отправки и чтение на любом канале (не имеет значения будет ли канал с буфером или без) всегда будут неблокируемыми.</p><br/>
<p>Если значение будет доступно на каком-либо канале, то <code>select</code> выполнит этот <code>case</code>. Если нет, то он немедленно выполнит <code>default</code>.</p><br/>
<pre><code class="go">package main

import (
    "fmt"
    "time"
)

var start time.Time

func init() {
    start = time.Now()
}

func service1(c chan string) {
    fmt.Println("service1() started", time.Since(start))
    c &lt;- "Hello from service 1"
}

func service2(c chan string) {
    fmt.Println("service2() started", time.Since(start))
    c &lt;- "Hello from service 2"
}

func main() {
    fmt.Println("main() started", time.Since(start))

    chan1 := make(chan string)
    chan2 := make(chan string)

    go service1(chan1)
    go service2(chan2)

    select {
    case res := &lt;-chan1:
        fmt.Println("Response from service 1", res, time.Since(start))
    case res := &lt;-chan2:
        fmt.Println("Response from service 2", res, time.Since(start))
    default:
        fmt.Println("No response received", time.Since(start))
    }

    fmt.Println("main() stopped", time.Since(start))
}
</code></pre><br/>
<p><a href="https://play.golang.org/p/rFMpc80EuT3" rel="nofollow">Пример в play.golang.org</a></p><br/>
<p>Вывод программы:</p><br/>
<pre><code class="plaintext">main() started 0s
No response received 0s
main() stopped 0s</code></pre><br/>
<p>Так как в приведенной программе каналы используются без буфера, и значение еще отсутствует, в обоих каналах будет исполнен <code>default</code>. Если бы в блоке <code>select</code> отсутствовал <code>default</code>, то произошла бы блокировка и результат был бы другим.</p><br/>
<p>Так как с <code>default</code> <code>select</code> не блокируется, планировщик не запускает доступные горутины. Но <code>main</code> можно заблокировать, вызвав <code>time.Sleep</code>. Таким образом все горутины будут исполнены, и когда управление перейдет в <code>main</code>, каналы будут иметь данные для чтения.</p><br/>
<pre><code class="go">package main

import (
    "fmt"
    "time"
)

var start time.Time

func init() {
    start = time.Now()
}

func service1(c chan string) {
    fmt.Println("service1() started", time.Since(start))
    c &lt;- "Hello from service 1"
}

func service2(c chan string) {
    fmt.Println("service2() started", time.Since(start))
    c &lt;- "Hello from service 2"
}

func main() {
    fmt.Println("main() started", time.Since(start))

    chan1 := make(chan string)
    chan2 := make(chan string)

    go service1(chan1)
    go service2(chan2)

    time.Sleep(3 * time.Second)

    select {
    case res := &lt;-chan1:
        fmt.Println("Response from service 1", res, time.Since(start))
    case res := &lt;-chan2:
        fmt.Println("Response from service 2", res, time.Since(start))
    default:
        fmt.Println("No response received", time.Since(start))
    }

    fmt.Println("main() stopped", time.Since(start))
}</code></pre><br/>
<p><a href="https://play.golang.org/p/eD0NHxHm9hN" rel="nofollow">Пример в play.golang.org</a></p><br/>
<p>По итогу мы получим следующий результат:</p><br/>
<pre><code class="plaintext">main() started 0s
service1() started 0s
service2() started 0s
Response from service 1 Hello from service 1 3.0001805s
main() stopped 3.0001805s</code></pre><br/>
<p>Или такой, в некоторых случаях:</p><br/>
<pre><code class="plaintext">main() started 0s
service1() started 0s
service2() started 0s
Response from service 2 Hello from service 2 3.0000957s
main() stopped 3.0000957s</code></pre><br/>
<h2 id="deadlock">Deadlock</h2><br/>
<p>Для того, чтобы избежать <code>deadlock</code>, можно использовать <code>default</code>, чтобы операции с каналами стали неблокируемыми, планировщик Go не будет планировать горутины для отправки данных в канал, даже если данные не доступны на данный момент.</p><br/>
<pre><code class="go">package main

import (
    "fmt"
    "time"
)

var start time.Time

func init() {
    start = time.Now()
}

func main() {
    fmt.Println("main() started", time.Since(start))

    chan1 := make(chan string)
    chan2 := make(chan string)

    select {
    case res := &lt;-chan1:
        fmt.Println("Response from chan1", res, time.Since(start))
    case res := &lt;-chan2:
        fmt.Println("Response from chan2", res, time.Since(start))
    default:
        fmt.Println("No goroutines available to send data", time.Since(start))
    }

    fmt.Println("main() stopped", time.Since(start))
}</code></pre><br/>
<p><a href="https://play.golang.org/p/S3Wxuqb8lMF" rel="nofollow">Пример в play.golang.org</a></p><br/>
<p>Вывод программы:</p><br/>
<pre><code class="plaintext">main() started 0s
No goroutines available to send data 0s
main() stopped 0s</code></pre><br/>
<p>Аналогично получению данных, операция отправки данных будет работать также в случае использования оператора <code>default</code>, если присутствуют другие горутины, готовые принять отправленные данные (в режиме ожидания).</p><br/>
<h3 id="nil-kanaly">nil каналы</h3><br/>
<p>Как мы уже знаем, нулевое значение в случае канала — это <code>nil</code>, из-за этого мы не может выполнять операции отправки или приема данных. При попытке отправить или принять данные через этот канал в блоке <code>select</code>, мы получим ошибку.</p><br/>
<pre><code class="go">package main

import "fmt"

func service(c chan string) {
    c &lt;- "response"
}

func main() {
    fmt.Println("main() started")

    var chan1 chan string

    go service(chan1)

    select {
    case res := &lt;-chan1:
        fmt.Println("Response from chan1", res)
    }

    fmt.Println("main() stopped")
}</code></pre><br/>
<p><a href="https://play.golang.org/p/uhraFubcF4S" rel="nofollow">Пример в play.golang.org</a></p><br/>
<p>Вывод программы:</p><br/>
<pre><code class="plaintext">main() started
fatal error: all goroutines are asleep - deadlock!

goroutine 1 [select (no cases)]:
main.main()
    program.go:17 +0xc0

goroutine 6 [chan send (nil chan)]:
main.service(0x0, 0x1)
    program.go:6 +0x40
created by main.main
    program.go:14 +0xa0</code></pre><br/>
<p>Из полученного результата мы можем заметить, что <code>select (no cases)</code> означает, что <code>select</code> оператор пустой, потому что конструкции <code>case</code> с нулевым каналом игнорируются. Но так как пустой <code>select{}</code> блокирует <code>main</code> горутину, активируется горутина <code>service</code>, которая попытается записать данные в <code>nil</code> канал, что впоследствии приведет к аварийному завершению программы со следующей ошибкой: <code>chan send (nil chan)</code>. Для того, чтобы этого избежать, можно использовать оператор <code>default</code>.</p><br/>
<pre><code class="go">package main

import "fmt"

func service(c chan string) {
    c &lt;- "response"
}

func main() {
    fmt.Println("main() started")

    var chan1 chan string

    go service(chan1)

    select {
    case res := &lt;-chan1:
        fmt.Println("Response from chan1", res)
    default:
        fmt.Println("No response")
    }

    fmt.Println("main() stopped")
}</code></pre><br/>
<p><a href="https://play.golang.org/p/upLsz52_CrE" rel="nofollow">Пример в play.golang.org</a></p><br/>
<p>Вывод программы:</p><br/>
<pre><code class="plaintext">main() started
No response
main() stopped</code></pre><br/>
<p>В приведенной программе блоки <code>case</code> игнорируются, так как блок <code>default</code> исполняется первым. Поэтому планировщик не запускает горутину <code>service</code>. Такие программы, естественно, писать не стоит, необходимо всегда проверять, что канал не <code>nil</code>.</p><br/>
<h3 id="dobavlyaem-timeout">Добавляем timeout</h3><br/>
<p>Ранее написанная программа не особенно полезна из-за того, что блок <code>default</code> выполнится раньше. Но иногда необходимо, чтобы определенный сервис ответил за определенное время, если он не отвечает, тогда должен выполниться блок <code>default</code>. Этого можно добиться, используя <code>case</code> с канальными операциями, которые будут разблокированы после заданного времени. Такая канальная операция предоставляется функцией <code>After</code> из пакета (package) <code>time</code>. Давайте рассмотрим следующий пример:</p><br/>
<pre><code class="go">package main

import (
    "fmt"
    "time"
)

var start time.Time

func init() {
    start = time.Now()
}

func service1(c chan string) {
    time.Sleep(3 * time.Second)
    c &lt;- "Hello from service 1"
}

func service2(c chan string) {
    time.Sleep(5 * time.Second)
    c &lt;- "Hello from service 2"
}

func main() {
    fmt.Println("main() started", time.Since(start))

    chan1 := make(chan string)
    chan2 := make(chan string)

    go service1(chan1)
    go service2(chan2)

    select {
    case res := &lt;-chan1:
        fmt.Println("Response from service 1", res, time.Since(start))
    case res := &lt;-chan2:
        fmt.Println("Response from service 2", res, time.Since(start))
    case &lt;-time.After(2 * time.Second):
        fmt.Println("No response received", time.Since(start))
    }

    fmt.Println("main() stopped", time.Since(start))
}</code></pre><br/>
<p><a href="https://play.golang.org/p/mda2t2IQK__X" rel="nofollow">Пример в play.golang.org</a></p><br/>
<p>Данная программа выдаст следующий результат через 2 секунды:</p><br/>
<pre><code class="plaintext">main() started 0s
No response received 2s
main() stopped 2s</code></pre><br/>
<p>В этой программе, благодаря конструкции <code>&lt;-time.After(2 * time.Second)</code> горутина <code>main</code> будет разблокирована через 2 секунды. <code>time.After</code> создаёт канал, по которому посылаются метки времени с заданным интервалом. Так как данные из каналов <code>chan1</code> и <code>chan2</code> не были получены, выполняется 3-й блок, после чего программа успешно завершается.</p><br/>
<p>Это может быть полезно в случае, когда вы не хотите ждать ответа от сервера продолжительное время. Если изменить <code>time.After(2 * time.Second)</code> на <code>time.After(10 * time.Second)</code> мы получим результат из <code>service1</code>.</p><br/>
<h3 id="pustoy-select">Пустой select</h3><br/>
<p>Подобно пустому <code>for{}</code>, пустой <code>select{}</code> так же является валидным, но есть подвох. Как мы уже знаем <code>select</code> блокируется до тех пор, пока один из блоков <code>case</code> не будет выполнен, но так как в пустом <code>select</code> отсутствуют блоки <code>case</code>, горутина не будет разблокирована, и как результат, мы получим <code>deadlock</code>.</p><br/>
<pre><code class="go">package main

import "fmt"

func service() {
    fmt.Println("Hello from service!")
}

func main() {
    fmt.Println("main() started")

    go service()

    select {}

    fmt.Println("main() stopped")
}</code></pre><br/>
<p><a href="https://play.golang.org/p/-pBd-BLMFOu" rel="nofollow">Пример в play.golang.org</a></p><br/>
<p>В результате мы получим следующий вывод:</p><br/>
<pre><code class="plaintext">main() started
Hello from service!
fatal error: all goroutines are asleep - deadlock!
goroutine 1 [select (no cases)]:
main.main()
        program.go:16 +0xba
exit status 2</code></pre><br/>
<h3 id="waitgroup">WaitGroup</h3><br/>
<p>Теперь давайте представим состояние, когда вам нужно узнать, что все горутины были выполнены (Примечание переводчика: например, операция сложения запущенная в нескольких горутинах). Такая задача является прямо противоположной тому, что мы делали с <code>select</code>. Здесь мы дожидаемся полного завершения всех горутин.</p><br/>
<p>На помощь нам приходит WaitGroup. Это структура со счетчиком, которая отслеживает сколько горутин вами было создано, и сколько из них было завершено (Примечание переводчика: сама она это делать не умеет, но есть методы, которые позволят вам добиться этого, так же подобного можно добиться с использованием каналов, но это считается устаревшим подходом и, как вы уже могли заметить, имеет ряд недостатков). Достижение счетчиком нуля будет означать, что все горутины были выполнены.</p><br/>
<p>Давайте разберем следующий пример:</p><br/>
<pre><code class="go">package main

import (
    "fmt"
    "sync"
    "time"
)

func service(wg *sync.WaitGroup, instance int) {
    time.Sleep(2 * time.Second)
    fmt.Println("Service called on instance", instance)
    wg.Done() // decrement counter
}

func main() {
    fmt.Println("main() started")
    var wg sync.WaitGroup // create waitgroup (empty struct)

    for i := 1; i &lt;= 3; i++ {
        wg.Add(1) // increment counter
        go service(&amp;wg, i)
    }

    wg.Wait() // blocks here
    fmt.Println("main() stopped")
}</code></pre><br/>
<p><a href="https://play.golang.org/p/8qrAD9ceOfJ" rel="nofollow">Пример в play.golang.org</a></p><br/>
<p>В этой программе мы создали пустой WaitGroup, внутри себя эта структура содержит приватные поля <code>noCopy</code> и <code>state1</code> (<a href="https://golang.org/src/sync/waitgroup.go?s=574:929#L10" rel="nofollow">https://golang.org/src/sync/waitgroup.go?s=574:929#L10</a>). Структура имеет три метода: <code>Add</code>, <code>Wait</code> и <code>Done</code>. Давайте их рассмотрим.</p><br/>
<p>Метод <code>Add</code> принимает <code>int</code> аргумент, который является <code>delta</code> (дельтой) для счетчика <code>WaitGroup</code>. Где счетчика — это число со значением, по умолчанию равным 0. Он хранит число запущенных горутин. Когда <code>WaitGroup</code> создана, значение счетчика будет равно 0, и мы можем увеличивать его, передавая <code>delta</code> как параметр метода <code>Add</code>. Счетчика не понимает автоматически, когда была запущена программа, поэтому нам нужно вручную увеличивать его, используя функцию <code>Add</code>.</p><br/>
<p>Метод <code>Wait</code> используется для блокировки текущей горутины, когда мы его вызываем. Как только счетчик достигнет 0, горутина будет разблокирована. Поэтому нам необходимо как-то уменьшать значение счетчика.</p><br/>
<p>Метод <code>Done</code> уменьшает значение счетчика. Он не принимает никаких параметров. (Примечание переводчика: если посмотреть исходники пакета <code>sync</code>, то можно увидеть, что внутри себя он просто вызывает <a href="https://golang.org/src/sync/waitgroup.go?s=574:929#L98" rel="nofollow">Add(-1)</a>).</p><br/>
<p>И так, после создания <code>wg</code>, мы запускаем итерацию в цикле <code>for</code> от 1 до 3х включительно. На каждой итерации мы запускаем горутину и инкрементируем счетчик на 1. Таким образом у нас будет 3 запущенных горутины, которые необходимо выполнить и <code>WaitGroup</code> со значением счетчика равным 3. Заметьте, что мы передали указатель на <code>wg</code> в горутину. Это необходимо, чтобы вызвать <code>Done</code> в горутине после завершения работы, что в свою очередь уменьшит значение счетчика.</p><br/>
<p>После выполнения цикла <code>for</code>, мы запускаем <code>wg.Wait()</code>, чтобы передать управление другим горутинам, и, как следствие, это заблокирует наш <code>main</code> до тех пор, пока все горутины не будут завершены, и значение счетчика не будет равно 0. После чего <code>main</code> будет разблокирована, и программа будет успешно завершена.</p><br/>
<p>Таким образом мы получим следующий вывод:</p><br/>
<pre><code class="plaintext">main() started
Service called on instance 1
Service called on instance 3
Service called on instance 2
main() stopped</code></pre><br/>
<p>Результат выше может отличаться, из-за порядка выполнения горутин.</p><br/>
<h3 id="pul-vorkerov">Пул воркеров</h3><br/>
<p>Как следует из названия, пул воркеров — это набор горутин, работающих одновременно для определенной задачи. В примере <code>WaitGroup</code> мы увидели набор горутин, работающих одновременно, но у них не было определенной задачи. Как только вы добавляете каналы в горутины, у них появляется какая-то работа, и они становятся пулом воркеров.</p><br/>
<pre><code class="go">package main

import (
    "fmt"
    "time"
)

// worker than make squares
func sqrWorker(tasks &lt;-chan int, results chan&lt;- int, id int) {
    for num := range tasks {
        time.Sleep(time.Millisecond) // simulating blocking task
        fmt.Printf("[worker %v] Sending result by worker %v\n", id, id)
        results &lt;- num * num
    }
}

func main() {
    fmt.Println("[main] main() started")

    tasks := make(chan int, 10)
    results := make(chan int, 10)

    // launching 3 worker goroutines
    for i := 0; i &lt; 3; i++ {
        go sqrWorker(tasks, results, i)
    }

    // passing 5 tasks
    for i := 0; i &lt; 5; i++ {
        tasks &lt;- i * 2 // non-blocking as buffer capacity is 10
    }

    fmt.Println("[main] Wrote 5 tasks")

    // closing tasks
    close(tasks)

    // receving results from all workers
    for i := 0; i &lt; 5; i++ {
        result := &lt;-results // blocking because buffer is empty
        fmt.Println("[main] Result", i, ":", result)
    }

    fmt.Println("[main] main() stopped")
}</code></pre><br/>
<p><a href="https://play.golang.org/p/IYiMV1I4lCj" rel="nofollow">Пример в play.golang.org</a></p><br/>
<p>Вывод программы:</p><br/>
<pre><code class="plaintext">[main] main() started
[main] Wrote 5 tasks
[worker 0] Sending result by worker 0
[worker 2] Sending result by worker 2
[worker 1] Sending result by worker 1
[main] Result 0 : 4
[main] Result 1 : 0
[main] Result 2 : 16
[worker 2] Sending result by worker 2
[main] Result 3 : 64
[worker 0] Sending result by worker 0
[main] Result 4 : 36
[main] main() stopped</code></pre><br/>
<p>Итак, давайте разберемся с тем, что тут происходит:</p><br/>
<ol>
<li>Функция <code>sqrWorker</code> принимает канал <code>tasks</code>, канал <code>results</code>, а так же <code>id</code>. Задача этой горутины — отправлять квадрат числа, полученного из канала <code>tasks</code>, в канал <code>results</code>.</li>
<li>В функции <code>main</code>, мы создали каналы <code>tasks</code> и <code>result</code> с размером буфера, равной 10. Следовательно, любая операция отправки будет неблокируемой, пока буфер не заполнится. Поэтому канал с буфером большого размера — это неплохая идея.</li>
<li>Затем мы порождаем несколько экземпляров <code>sqrWorker</code> в виде горутин с двумя вышеописанными каналами и параметром <code>id</code>, чтобы позже получить информацию о том, какой воркер выполняет задачу.</li>
<li>Далее мы передали 5 значений каналу <code>tasks</code>, операция будет неблокируемой, так как размер буфера не превышен.</li>
<li>Так как мы закончили с каналом <code>tasks</code>, закрываем его. В этом нет необходимости, но это сэкономит много времени в будущем, если появятся ошибки.</li>
<li>Используя цикл <code>for</code> с 5ю итерациями, мы извлекаем результат из канала <code>results</code>. Так как операция чтения на пустом буфере является блокируемой, планировщик запустит горутину из пула воркеров. До тех пор, пока горутина не вернет результат, <code>main</code> будет заблокирован.</li>
<li>Поскольку мы симулируем операцию блокировки в горутине, это приведет к вызову планировщиком другой доступной горутины для запуска. Когда горутина запустится, она запишет результат в канал <code>results</code>, а так как операция записи в канал с буфером является неблокируемым до тех пор, пока буфер не заполнен, блокировки при записи не произойдет. Таким образом как только одна из горутин завершится, запустятся другие горутины и считают данные из канала <code>tasks</code>. После того, как все горутины считают данные из <code>tasks</code>, цикл <code>for</code> завершится, а канал <code>tasks</code> будет пустым. Так же не произойдет ошибка <code>deadlock</code>, так как канал <code>tasks</code> был закрыт.</li>
<li>Иногда все воркеры могут находиться в режиме ожидания, поэтому <code>main</code> программа будет работать до тех пор, пока канал <code>results</code> не будет пуст.</li>
<li>После того, как все воркеры отработают, <code>main</code> восстановит контроль, выведет оставшиеся результаты из канала <code>results</code>, и продолжит выполнение.</li>
</ol><br/>
<p>Приведенный пример достаточно большой, но прекрасно объясняет, как несколько горутин могут извлекать данные из канала и выполнять свою работу. Горутины весьма эффективны, когда они могут блокироваться. Если убрать вызов <code>time.Sleep()</code>, то только одна горутина будет выполняться, так как другие горутины не будут запланированы, до тех пор пока цикл не закончится и горутина не завершится.</p><br/>
<blockquote>Вы можете получить другой результат в приведенном примере, в зависимости от скорости работы вашей системы.</blockquote><p>Давайте воспользуемся концепцией <code>WaitGroup</code> для синхронизации горутин. Используя предыдущий пример с <code>WaitGroup</code>, мы можем получить те же результаты, но более элегантно.</p><br/>
<pre><code class="go">package main

import (
    "fmt"
    "sync"
    "time"
)

// worker than make squares
func sqrWorker(wg *sync.WaitGroup, tasks &lt;-chan int, results chan&lt;- int, instance int) {
    for num := range tasks {
        time.Sleep(time.Millisecond)
        fmt.Printf("[worker %v] Sending result by worker %v\n", instance, instance)
        results &lt;- num * num
    }

    // done with worker
    wg.Done()
}

func main() {
    fmt.Println("[main] main() started")

    var wg sync.WaitGroup

    tasks := make(chan int, 10)
    results := make(chan int, 10)

    // launching 3 worker goroutines
    for i := 0; i &lt; 3; i++ {
        wg.Add(1)
        go sqrWorker(&amp;wg, tasks, results, i)
    }

    // passing 5 tasks
    for i := 0; i &lt; 5; i++ {
        tasks &lt;- i * 2 // non-blocking as buffer capacity is 10
    }

    fmt.Println("[main] Wrote 5 tasks")

    // closing tasks
    close(tasks)

    // wait until all workers done their job
    wg.Wait()

    // receving results from all workers
    for i := 0; i &lt; 5; i++ {
        result := &lt;-results // non-blocking because buffer is non-empty
        fmt.Println("[main] Result", i, ":", result)
    }

    fmt.Println("[main] main() stopped")
}</code></pre><br/>
<p><a href="https://play.golang.org/p/0rRfchn7sL1" rel="nofollow">Пример в play.golang.org</a></p><br/>
<p>Результат работы программы:</p><br/>
<pre><code class="plaintext">[main] main() started
[main] Wrote 5 tasks
[worker 0] Sending result by worker 0
[worker 2] Sending result by worker 2
[worker 1] Sending result by worker 1
[worker 2] Sending result by worker 2
[worker 0] Sending result by worker 0
[main] Result 0 : 4
[main] Result 1 : 0
[main] Result 2 : 16
[main] Result 3 : 64
[main] Result 4 : 36
[main] main() stopped</code></pre><br/>
<p>В приведенном результате мы получили немного другой, более аккуратный вывод, потому что операция чтения из канала <code>results</code> в <code>main</code> не блокируется, так как канал <code>results</code> уже содержит данные из-за вызванного ранее <code>wg.Wait()</code>. Используя <code>WaitGroup</code>, мы можем предотвратить много (ненужных) переключений контекста (планирование горутин и их запуск), в данном случае 7 против 9 в предыдущем примере. Но при этом вам приходится ожидать завершения всех горутин.</p><br/>
<h3 id="myuteks">Мьютекс</h3><br/>
<p>Мьютекс — это один из самых простых концепций в Go. Но прежде чем разобраться в нем, давайте для начала разберемся в понятии <code>race condition</code>(<a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B5_%D0%B3%D0%BE%D0%BD%D0%BA%D0%B8" rel="nofollow">состоянии гонки</a>). Горутины имеют независимый стек, следовательно нет необходимости в обмене данными между ними. Но, иногда, необходимо использовать общие данные между несколькими горутинами. В этом случае несколько горутин пытаются взаимодействовать с данными в общей области памяти, что иногда приводит к непредсказуемому результату. Рассмотрим простой пример:</p><br/>
<pre><code class="go">package main

import (
    "fmt"
    "sync"
)

var i int // i == 0

// goroutine increment global variable i
func worker(wg *sync.WaitGroup) {
    i = i + 1
    wg.Done()
}

func main() {
    var wg sync.WaitGroup

    for i := 0; i &lt; 1000; i++ {
        wg.Add(1)
        go worker(&amp;wg)
    }

    // wait until all 1000 goroutines are done
    wg.Wait()

    // value of i should be 1000
    fmt.Println("value of i after 1000 operations is", i)
}</code></pre><br/>
<p><a href="https://play.golang.org/p/MQNepChxiEa" rel="nofollow">Пример в play.golang.org</a></p><br/>
<p>В приведенной программе мы порождаем 1000 горутин, которые увеличивают значение глобальной переменной <code>i</code>, равной изначально 0. Мы написали программу с использованием <code>WaitGroup</code>, поскольку мы хотим, чтобы все 1000 горутин увеличивали значение <code>i</code> последовательно, и, в результате, итоговое значение было равно 1000. Когда <code>main</code> восстанавливается после вызова <code>wg.Wait()</code>, мы выводим значение <code>i</code>. Давайте посмотрим на конечный результат:</p><br/>
<pre><code class="plaintext">value of i after 1000 operations is 937</code></pre><br/>
<p>Что? Почему мы получили значение меньше 1000? Возможно часть горутин не отработала. Но, в действительности, произошло <code>race condition</code>. Посмотрим, как это могло случиться.</p><br/>
<p>Вычисление <code>i = i + 1</code> состоит из трех шагов:</p><br/>
<ol>
<li>Получить значение <code>i</code></li>
<li>Увеличить на 1</li>
<li>Обновить значение <code>i</code> с новым значением</li>
</ol><br/>
<p>Давайте представим следующий сценарий, в котором между этими шагами были запланированы разные горутины. К примеру, рассмотрим 2 горутины из пула 1000 горутин, а именно. G1 и G2.</p><br/>
<p>G1 запускается, когда <code>i</code> равна 0, после второго шага <code>i</code> стала равной 1. Но перед тем, как G1 изменит значение <code>i</code> на 1 в шаге 3, новая горутина G2 уже была запланирована, и эта горутина выполнит те же шаги. В случае G2, значение <code>i</code> все еще 0, поэтому на третьем шаге значение <code>i</code> будет равно 1, в это время G1 собирается закончить третий шаг и изменить значение <code>i</code> на 1. В идеальном мире, где горутины планируются после выполнения всех 3-х шагов, успешное выполнение 2х горутин привело бы к значению <code>i</code> равному 2, но это не так. Поэтому, мы можем предположить, почему наша программа не выдает значение <code>i</code> равным 1000.</p><br/>
<p>Как мы знаем, горутины планируются совместно и до тех пор, пока горутина не заблокируется по одному из условий, другая горутина не будет запланирована. Но операция <code>i = i + 1</code> не является блокируемой, тогда почему планировщик Go планирует другие горутины?</p><br/>
<p>Вы можете посмотреть ответ на <a href="https://stackoverflow.com/questions/37469995/goroutines-are-cooperatively-scheduled-does-that-mean-that-goroutines-that-don" rel="nofollow">stackoverflow</a>. В любом случае не следует полагаться на алгоритм планирования Go и реализовывать собственную логику для синхронизации различных программ.</p><br/>
<p>Один из способов удостовериться, что горутина выполнит все 3 вышеуказанных шага за раз, это использовать мьютекс. <a href="https://ru.wikipedia.org/wiki/%D0%9C%D1%8C%D1%8E%D1%82%D0%B5%D0%BA%D1%81" rel="nofollow">Мьютекс</a> — это концепция в программировании, где только один поток может выполнять несколько операций одновременно. Это делается с помощью подпрограммы, получающей блокировку для выполнения любых манипуляции со значением, которое она должна изменить, а затем снимает блокировку после. Когда значение заблокировано, никакая другая подпрограмма не может читать или записывать его.</p><br/>
<p>В Go мьютексы — это структура данных, которую предоставляет пакет <code>sync</code>. В Go перед выполнением любой операции со значением, которое может вызвать <code>race condition</code>, мы получаем эксклюзивную блокировку, используя метод <code>mutex.Lock()</code>. Как только мы выполнили операцию <code>i = i + 1</code> в ранее написанной программе, мы снимаем блокировки, используя метод <code>mutext.Unlock()</code>. Когда любая другая горутина попытается прочитать или записать значение <code>i</code> при наличии блокировки, эта программа будет блокироваться до тех пор, пока мьютекс не будет разблокирован. И горутина сможет безопасно читать и писать данные в переменную <code>i</code>. Запомните, что любые переменные, находящиеся между <code>Lock</code> и <code>Unlock</code>, будут недоступны для других горутин до тех пор, пока не выполнится операция снятия блокировки.</p><br/>
<p>Давайте изменим предыдущий пример, используя мьютекс.</p><br/>
<pre><code class="go">package main

import (
    "fmt"
    "sync"
)

var i int // i == 0

// goroutine increment global variable i
func worker(wg *sync.WaitGroup, m *sync.Mutex) {
    m.Lock() // acquire lock
    i = i + 1
    m.Unlock() // release lock
    wg.Done()
}

func main() {
    var wg sync.WaitGroup
    var m sync.Mutex

    for i := 0; i &lt; 1000; i++ {
        wg.Add(1)
        go worker(&amp;wg, &amp;m)
    }

    // wait until all 1000 goroutines are done
    wg.Wait()

    // value of i should be 1000
    fmt.Println("value of i after 1000 operations is", i)
}</code></pre><br/>
<p>В данной программе мы создали мьютекс и передали его указатель во все горутины, прежде чем выполнить операцию с переменной <code>i</code>, мы получили эксклюзивную блокировку, используя <code>m.Lock()</code>, а после операций с переменной <code>i</code> мы сняли блокировку, используя <code>m.Unlock()</code>. Таким образом мы получим следующий результат:</p><br/>
<pre><code class="plaintext">value of i after 1000 operations is 1000</code></pre><br/>
<p>Из приведенного результата видно, что мьютекс помог нам разрешить <code>race condition</code>. Но старайтесь избегать использования общих ресурсов между горутинами.</p><br/>
<blockquote>Вы можете проверить программу на <code>race condition</code> в Go, используя флаг <code>race</code>, при запуске программы. <code>go run -race program.go</code>. Более подробно об этом можно прочитать <a href="https://blog.golang.org/race-detector" rel="nofollow">здесь</a>.</blockquote><br/>
<h2 id="patterny-konkurentnogo-programmirovaniya">Паттерны конкурентного программирования</h2><br/>
<p>Существует множество способов, с помощью которых параллелизм делает нашу повседневную жизнь проще. Ниже приведены несколько концепций и методологий, с помощью которых мы можем сделать программы быстрее и надежнее.</p><br/>
<h3 id="generator">Генератор</h3><br/>
<p>Используя каналы, мы можем достаточно просто реализовать генератор. Так как вычисления в генераторе могут являться вычислительно дорогими, то мы могли бы сделать генерацию данных конкурентно. Таким образом, программе не нужно ждать, пока все данные будут сгенерированы. Например, генерация ряда Фибоначчи.</p><br/>
<pre><code class="go">package main

import "fmt"

// fib returns a channel which transports fibonacci numbers
func fib(length int) &lt;-chan int {
    // make buffered channel
    c := make(chan int, length)

    // run generation concurrently
    go func() {
        for i, j := 0, 1; i &lt; length; i, j = i+j, i {
            c &lt;- i
        }
        close(c)
    }()

    // return channel
    return c
}

func main() {
    // read 10 fibonacci numbers from channel returned by `fib` function
    for fn := range fib(10) {
        fmt.Println("Current fibonacci number is", fn)
    }
}</code></pre><br/>
<pre><code class="plaintext">Current fibonacci number is 0
Current fibonacci number is 1
Current fibonacci number is 1
Current fibonacci number is 2
Current fibonacci number is 3
Current fibonacci number is 5
Current fibonacci number is 8</code></pre><br/>
<p>Используя функцию fib, мы получаем канал, который мы можем использовать в цикле. Находясь внутри функции fib, мы создаем и возвращаем канал только для приема. Возвращаемый канал преобразуется из двунаправленного канала в однонаправленный канал для приема. Используя анонимную горутину, мы помещаем числа Фибоначчи в этот канал. Как только мы закончили с циклом <code>for</code>, мы закрываем канал внутри анонимной горутины. В <code>main</code>, используя <code>range</code>, мы итерируем данные канала, полученные после вызова функции <code>fib</code>.</p><br/>
<h3 id="fan-in-i-fan-out">Fan-in и Fan-out</h3><br/>
<p>Fan-in — это стратегия мультиплексирования, при которой входы нескольких каналов объединяются в один выходной канал. Fan-out — это обратная операция, при которой один канал разделяется на несколько каналов.</p><br/>
<pre><code class="go">
package main

import (
    "fmt"
    "sync"
)

// return channel for input numbers
func getInputChan() &lt;-chan int {
    // make return channel
    input := make(chan int, 100)

    // sample numbers
    numbers := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

    // run goroutine
    go func() {
        for num := range numbers {
            input &lt;- num
        }
        // close channel once all numbers are sent to channel
        close(input)
    }()

    return input
}

// returns a channel which returns square of numbers
func getSquareChan(input &lt;-chan int) &lt;-chan int {
    // make return channel
    output := make(chan int, 100)

    // run goroutine
    go func() {
        // push squares until input channel closes
        for num := range input {
            output &lt;- num * num
        }

        // close output channel once for loop finishes
        close(output)
    }()

    return output
}

// returns a merged channel of `outputsChan` channels
// this produce fan-in channel
// this is variadic function
func merge(outputsChan ...&lt;-chan int) &lt;-chan int {
    // create a WaitGroup
    var wg sync.WaitGroup

    // make return channel
    merged := make(chan int, 100)

    // increase counter to number of channels `len(outputsChan)`
    // as we will spawn number of goroutines equal to number of channels received to merge
    wg.Add(len(outputsChan))

    // function that accept a channel (which sends square numbers)
    // to push numbers to merged channel
    output := func(sc &lt;-chan int) {
        // run until channel (square numbers sender) closes
        for sqr := range sc {
            merged &lt;- sqr
        }
        // once channel (square numbers sender) closes,
        // call `Done` on `WaitGroup` to decrement counter
        wg.Done()
    }

    // run above `output` function as groutines, `n` number of times
    // where n is equal to number of channels received as argument the function
    // here we are using `for range` loop on `outputsChan` hence no need to manually tell `n`
    for _, optChan := range outputsChan {
        go output(optChan)
    }

    // run goroutine to close merged channel once done
    go func() {
        // wait until WaitGroup finishes
        wg.Wait()
        close(merged)
    }()

    return merged
}

func main() {
    // step 1: get input numbers channel
    // by calling `getInputChan` function, it runs a goroutine which sends number to returned channel
    chanInputNums := getInputChan()

    // step 2: `fan-out` square operations to multiple goroutines
    // this can be done by calling `getSquareChan` function multiple times where individual function call returns a channel which sends square of numbers provided by `chanInputNums` channel
    // `getSquareChan` function runs goroutines internally where squaring operation is ran concurrently
    chanOptSqr1 := getSquareChan(chanInputNums)
    chanOptSqr2 := getSquareChan(chanInputNums)

    // step 3: fan-in (combine) `chanOptSqr1` and `chanOptSqr2` output to merged channel
    // this is achieved by calling `merge` function which takes multiple channels as arguments
    // and using `WaitGroup` and multiple goroutines to receive square number, we can send square numbers
    // to `merged` channel and close it
    chanMergedSqr := merge(chanOptSqr1, chanOptSqr2)

    // step 4: let's sum all the squares from 0 to 9 which should be about `285`
    // this is done by using `for range` loop on `chanMergedSqr`
    sqrSum := 0

    // run until `chanMergedSqr` or merged channel closes
    // that happens in `merge` function when all goroutines pushing to merged channel finishes
    // check line no. 86 and 87
    for num := range chanMergedSqr {
        sqrSum += num
    }

    // step 5: print sum when above `for loop` is done executing which is after `chanMergedSqr` channel closes
    fmt.Println("Sum of squares between 0-9 is", sqrSum)
}</code></pre><br/>
<p>Пройдем по шагам.</p><br/>
<ol>
<li>Получаем канал <code>chanInputNums</code>, посредством вызова функции <code>getInputChan</code>. Функция <code>getInputChan</code> создает канал и возвращает его как канал, доступный только для чтения, а также запускает анонимную горутину, которая последовательно помещает в канал числа из массива <code>numbers</code> и закрывает канал.</li>
<li>Разделяем наш канал (fan-out) на два канала(<code>chanOptSqr1</code> и <code>chanOptSqr2</code>), передавая его два раза функции <code>getSquareChan</code>. Функция <code>getSquareChan</code> создает канал и возвращает его как канал, доступный только для чтения, а также запускает анонимную горутину для вычисления квадрата чисел на основе данных канала, полученного в качестве аргумента функции.</li>
<li>Собираем данные из каналов в один (fan-in), используя функцию <code>merge</code>. В функции <code>merge</code> мы создаем <code>WaitGroup</code>, а также новый канал(<code>merged</code>), где мы объединим все данные из списка каналов <code>outputsChan</code>, после, мы увеличиваем счетчик на основании числа полученных каналов, подготавливаем анонимную функцию для чтения данных из канала и группировки данных в наш новый канал <code>merged</code>, а также уменьшим значение счетчика, когда все данные из переданного канала будут считаны. Вызываем нашу анонимную функцию для каждого канала в качестве горутины. А так же создаем и стартуем еще одну анонимную горутину для того, чтобы дождаться выполнения операции объединения всех данных в один канал и после этого закрываем канал в рамках анонимной функции. После чего возвращаем наш новый канал <code>merged</code>.</li>
<li>Считываем данные из канала <code>chanMergedSqr</code> используя <code>for</code> и <code>range</code>, и суммируем полученные данные.</li>
<li>В конце выводим наш результат.</li>
</ol><br/>
<p>Вывод программы:</p><br/>
<pre><code class="plaintext">Sum of squares between 0-9 is 285</code></pre><br/>
<p>UPDATE:</p><br/>
<p>Дополнительная литература по внутреннему устройству каналов:</p><br/>
<ol>
<li><a href="https://habr.com/ru/post/308070/">Как устроены каналы в Go</a></li>
<li><a href="https://medium.com/@victor_nerd/%D0%BF%D0%BE%D0%B4-%D0%BA%D0%B0%D0%BF%D0%BE%D1%82%D0%BE%D0%BC-golang-%D0%BA%D0%B0%D0%BA-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D1%8E%D1%82-%D0%BA%D0%B0%D0%BD%D0%B0%D0%BB%D1%8B-%D1%87%D0%B0%D1%81%D1%82%D1%8C-1-e1da9e3e104d" rel="nofollow">Под капотом Golang — как работают каналы. Часть 1.</a></li>
<li><a href="https://medium.com/@victor_nerd/golang-channel-internal-part2-b4e37ad9a118" rel="nofollow">Строение каналов в Golang. Часть 2.</a></li>
</ol></div></div></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <!----></div> <div class="tm-article-presenter__meta"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bgolang%5D" class="tm-tags-list__link">golang</a></li></ul></div> <div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/hub/go/" class="tm-hubs-list__link">
    Go
  </a></li></ul></div></div></article></div> <!----></div> <div class="tm-article-sticky-panel"><div class="tm-data-icons tm-article-sticky-panel__icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg height="24" width="24" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon tm-votes-meter__icon_appearance-article"><title>Всего голосов 22: ↑22 и ↓0</title> <use xlink:href="/img/megazord-v25.29545111.svg#counter-rating"></use></svg> <span title="Всего голосов 22: ↑22 и ↓0" class="tm-votes-meter__value tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_appearance-article tm-votes-meter__value_rating">+22</span></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="24" width="24" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v25.29545111.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">61K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="24" width="24" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v25.29545111.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    222
  </span></button> <!----> <div title="Поделиться" class="tm-sharing tm-data-icons__item"><button type="button" class="tm-sharing__button"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="tm-sharing__icon"><path fill="currentColor" d="M13.8 13.8V18l7.2-6.6L13.8 5v3.9C5 8.9 3 18.6 3 18.6c2.5-4.4 6-4.8 10.8-4.8z"></path></svg></button> <DIV class="v-portal" style="display:none;"></DIV></div> <DIV class="v-portal" style="display:none;"></DIV></div> </div></div> <DIV class="v-portal" style="display:none;"></DIV> <div class="tm-article-presenter__footer"><div class="tm-article-blocks"><!----> <section class="tm-block tm-block tm-block_spacing-bottom"><!----> <div class="tm-block__body tm-block__body tm-block__body_variant-balanced"><div class="tm-article-author"> <div class="tm-user-card tm-article-author__user-card tm-user-card tm-user-card_variant-article"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="/ru/users/alex89v/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><div class="tm-entity-image"><svg class="tm-svg-img tm-image-placeholder tm-image-placeholder_pink"><!----> <use xlink:href="/img/megazord-v25.29545111.svg#placeholder-user"></use></svg></div></a> <div class="tm-user-card__meta"><div title=" 12 голосов " class="tm-karma tm-user-card__karma tm-karma"><div class="tm-karma__votes tm-karma__votes_positive">
    12
  </div> <div class="tm-karma__text">
    Карма
  </div></div> <div title="Рейтинг пользователя" class="tm-rating tm-user-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter tm-rating__counter">0</div></div> <div class="tm-rating__text tm-rating__text">
    Рейтинг
  </div></div></div></div></div> <div class="tm-user-card__info tm-user-card__info tm-user-card__info_variant-article"><div class="tm-user-card__title tm-user-card__title tm-user-card__title_variant-article"><span class="tm-user-card__name tm-user-card__name tm-user-card__name_variant-article">Алексей</span> <a href="/ru/users/alex89v/" class="tm-user-card__nickname tm-user-card__nickname tm-user-card__nickname_variant-article">
          @alex89v
        </a> <!----></div> <p class="tm-user-card__short-info tm-user-card__short-info tm-user-card__short-info_variant-article">Разработчик</p></div></div> <div class="tm-user-card__buttons tm-user-card__buttons tm-user-card__buttons_variant-article"><!----> <!----> <!----> <!----> <!----></div></div> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----></section> <div class="tm-adfox-banner__container tm-page-article__banner"><!----> <div id="adfox_164725660339535756" class="tm-adfox-banner tm-adfox-banner tm-adfox-banner_variant-leaderboard"></div></div> <div class="tm-article-blocks__comments"><div class="tm-article-page-comments"><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a href="/ru/post/490336/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style"><svg height="24" width="24" class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted"><title>Комментарии</title> <use xlink:href="/img/megazord-v25.29545111.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted">
       Комментарии 5 
    </span></a> <!----></div></div></div>  <!----> <div><div><!----> <!----> <!----> <!----> <!----> <!----> <!----> <!----> <!----> <!----> <!----> <!----> <!----> <!----> <!----> <!----> <!----> <!----> <!----> <!----> <!----> <!----> <div class="tm-placeholder-promo"><div class="tm-placeholder-promo__header"><div class="tm-placeholder__line tm-placeholder__line_promo-title"></div></div> <div class="tm-placeholder-promo__body"><div class="tm-placeholder-promo__posts"><div class="tm-placeholder-promo__post"><div class="tm-placeholder-promo__image"></div> <div class="tm-placeholder__line tm-placeholder__line_post-title"></div></div> <div class="tm-placeholder-promo__post"><div class="tm-placeholder-promo__image"></div> <div class="tm-placeholder__line tm-placeholder__line_post-title"></div></div> <div class="tm-placeholder-promo__post"><div class="tm-placeholder-promo__image"></div> <div class="tm-placeholder__line tm-placeholder__line_post-title"></div></div></div> <div class="tm-placeholder-promo__dots"><div class="tm-placeholder-promo__dot"></div> <div class="tm-placeholder-promo__dot"></div> <div class="tm-placeholder-promo__dot"></div></div></div></div></div></div> <div><!----> <!----> <!----> <!----> <!----> <!----> <!----> <!----> <!----> <!----> <!----> <!----> <!----> <!----> <!----> <!----> <!----> <!----> <div class="tm-placeholder-inset tm-placeholder-tasks"><div class="tm-placeholder-inset__header"><div class="tm-placeholder__line tm-placeholder__line_inset-header loads"></div></div> <div class="tm-placeholder-inset__body"><ul class="tm-placeholder-list"><li class="tm-placeholder-list__item tm-placeholder-list__item_inset"><div class="tm-placeholder-list__title-container"><div class="tm-placeholder__line tm-placeholder__line_item-title loads"></div></div> <div class="tm-project-block-items__properties"><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width: 100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width: 100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width: 100px;"></span></span></div></li><li class="tm-placeholder-list__item tm-placeholder-list__item_inset"><div class="tm-placeholder-list__title-container"><div class="tm-placeholder__line tm-placeholder__line_item-title loads"></div></div> <div class="tm-project-block-items__properties"><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width: 100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width: 100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width: 100px;"></span></span></div></li><li class="tm-placeholder-list__item tm-placeholder-list__item_inset"><div class="tm-placeholder-list__title-container"><div class="tm-placeholder__line tm-placeholder__line_item-title loads"></div></div> <div class="tm-project-block-items__properties"><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width: 100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width: 100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width: 100px;"></span></span></div></li><li class="tm-placeholder-list__item tm-placeholder-list__item_inset"><div class="tm-placeholder-list__title-container"><div class="tm-placeholder__line tm-placeholder__line_item-title loads"></div></div> <div class="tm-project-block-items__properties"><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width: 100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width: 100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width: 100px;"></span></span></div></li><li class="tm-placeholder-list__item tm-placeholder-list__item_inset"><div class="tm-placeholder-list__title-container"><div class="tm-placeholder__line tm-placeholder__line_item-title loads"></div></div> <div class="tm-project-block-items__properties"><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width: 100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width: 100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width: 100px;"></span></span></div></li></ul></div> <div class="tm-placeholder-inset__footer"><div class="tm-placeholder__line tm-placeholder__line_inset-footer loads"></div></div></div> <!----> <!----> <!----> <!----></div> <!----> </div></div></div></div></div> <div class="tm-page__sidebar"><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__ads tm-layout-sidebar__ads_initial"><div class="tm-adfox-banner__container tm-layout-sidebar__banner tm-layout-sidebar__banner_top"><!----> <div id="adfox_164725680533065327" class="tm-adfox-banner tm-adfox-banner tm-adfox-banner_variant-half-page"></div></div></div> <div class="tm-sexy-sidebar tm-sexy-sidebar_initial" style="margin-top:0px;"><!----> <section data-async-called="true" class="tm-block tm-block tm-block_spacing-bottom"><header class="tm-block__header tm-block__header"><div class="tm-block__header-container"><h2 class="tm-block__title">Работа</h2> </div> <!----></header> <div class="tm-block__body tm-block__body"><div class="tm-vacancies-block__item"><a href="https://career.habr.com/vacancies/go_razrabotchik" target="_blank" class="tm-vacancies-block__vacancy-title">
        Go разработчик
      </a> <div class="tm-vacancies-block__vacancies-count">
        125
    вакансий
      </div></div></div> <footer class="tm-block__footer"><a href="https://career.habr.com/catalog" class="tm-block-extralink">
      Все вакансии
    </a></footer></section> <div class="tm-adfox-banner__container tm-layout-sidebar__banner tm-layout-sidebar__banner_bottom"><!----> <div id="adfox_164725691003361602" class="tm-adfox-banner tm-adfox-banner tm-adfox-banner_variant-medium-rectangle"></div></div></div></div></div></div></div></div></main> <!----></div> <div class="tm-footer-menu"><div class="tm-page-width"><div class="tm-footer-menu__container"><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Ваш аккаунт
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/ru/post/490336/&amp;hl=ru" rel="nofollow" target="_self">
                Войти
              </a></li><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/ru/post/490336/&amp;hl=ru" rel="nofollow" target="_self">
                Регистрация
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Разделы
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/" class="footer-menu__item-link router-link-active">
                Публикации
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/news/" class="footer-menu__item-link">
                Новости
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/hubs/" class="footer-menu__item-link">
                Хабы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/companies/" class="footer-menu__item-link">
                Компании
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/users/" class="footer-menu__item-link">
                Авторы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/sandbox/" class="footer-menu__item-link">
                Песочница
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Информация
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/docs/help/" class="footer-menu__item-link">
                Устройство сайта
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/authors/codex/" class="footer-menu__item-link">
                Для авторов
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/companies/corpblogs/" class="footer-menu__item-link">
                Для компаний
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/docs/transparency/" class="footer-menu__item-link">
                Документы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement" target="_blank">
                Соглашение
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/" target="_blank">
                Конфиденциальность
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Услуги
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQLwRfQmXibiUlWaRg-BAc38s7oM3lJiaPju7qmdJsp8ysIvZ_G-Npem0njJLMozE2bPHMpDqiI5hhy/pub?start=false&amp;loop=false&amp;delayms=60000&amp;slide=id.g91a03369cd_4_297" target="_blank">
                Реклама
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habrastorage.org/storage/stuff/habr/service_price.pdf" target="_blank">
                Тарифы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQJJds8-Di7BQSP_guHxICN7woVYoN5NP_22ra-BIo4bqnTT9FR6fB-Ku2P0AoRpX0Ds-LRkDeAoD8F/pub?start=false&amp;loop=false&amp;delayms=60000" target="_blank">
                Контент
              </a></li><li class="tm-footer-menu__list-item"><a href="https://tmtm.timepad.ru/" target="_blank">
                Семинары
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/megaprojects/" class="footer-menu__item-link">
                Мегапроекты
              </a></li></ul></div></div></div></div></div> <div class="tm-footer"><div class="tm-page-width"><div class="tm-footer__container"><!----> <div class="tm-footer__social"><a href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Facebook</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Twitter</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>VK</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-vkontakte"></use></svg></a><a href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Telegram</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Youtube</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a href="https://zen.yandex.ru/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Яндекс Дзен</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-zen"></use></svg></a></div> <DIV class="v-portal" style="display:none;"></DIV> <button class="tm-footer__link"><!---->
        Настройка языка
      </button> <a href="/ru/about" class="tm-footer__link">
        О сайте
      </a> <a href="/ru/feedback/" class="tm-footer__link">
        Техническая поддержка
      </a> <!----> <a href="/berserk-mode-nope" class="tm-footer__link">
        Вернуться на старую версию
      </a> <div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2022, </span> <span class="tm-copyright__name"><a href="https://company.habr.com/" rel="noopener" target="_blank" class="tm-copyright__link">Habr</a></span></span></div></div></div></div> <!----> <!----></div> <div class="vue-portal-target"></div></div>
<script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"490336":{"id":"490336","timePublished":"2020-02-28T08:28:02+00:00","isCorporative":false,"lang":"ru","titleHtml":"Анатомия каналов в Go","leadData":{"textHtml":"\u003Cp\u003EПривет, Хабр! Представляю вашему вниманию перевод статьи \u003Ca href=\"https:\u002F\u002Fmedium.com\u002Frungo\u002Fanatomy-of-channels-in-go-concurrency-in-go-1ec336086adb\" rel=\"nofollow\"\u003E&quot;Anatomy of Channels in Go&quot;\u003C\u002Fa\u003E автора Uday Hiwarale.\u003C\u002Fp\u003E\u003Cbr\u003E\r\n\u003Ch2 id=\"chto-takoe-kanaly\"\u003EЧто такое каналы?\u003C\u002Fh2\u003E\u003Cbr\u003E\r\n\u003Cp\u003EКанал — это объект связи, с помощью которого горутины обмениваются данными. Технически это конвейер (или труба), откуда можно считывать или помещать данные. То есть одна горутина может отправить данные в канал, а другая — считать помещенные в этот канал данные.\u003C\u002Fp\u003E\u003Cbr\u003E\r\n\u003Ch2 id=\"sozdanie-kanala\"\u003EСоздание канала\u003C\u002Fh2\u003E\u003Cbr\u003E\r\n\u003Cp\u003EGo для создания канала предоставляет ключевое слово chan. Канал может передавать данные только одного типа, данные других типов через это канал передавать невозможно.\u003C\u002Fp\u003E","imageUrl":null,"buttonTextHtml":"Читать дальше &rarr;","image":null},"editorVersion":"1.0","postType":"article","postLabels":[{"type":"sandbox","data":null}],"author":{"scoreStats":{"score":12,"votesCount":12},"rating":0,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"id":"511966","alias":"alex89v","fullname":"Алексей","avatarUrl":null,"speciality":"Разработчик"},"statistics":{"commentsCount":5,"favoritesCount":222,"readingCount":61136,"score":22,"votesCount":22},"hubs":[{"relatedData":null,"id":"17748","alias":"go","type":"collective","title":"Go","titleHtml":"Go","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"}],"relatedData":null,"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003E\u003Cp\u003EПривет, Хабр! Представляю вашему вниманию перевод статьи \u003Ca href=\"https:\u002F\u002Fmedium.com\u002Frungo\u002Fanatomy-of-channels-in-go-concurrency-in-go-1ec336086adb\" rel=\"nofollow\"\u003E\"Anatomy of Channels in Go\"\u003C\u002Fa\u003E автора Uday Hiwarale.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"chto-takoe-kanaly\"\u003EЧто такое каналы?\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКанал — это объект связи, с помощью которого горутины обмениваются данными. Технически это конвейер (или труба), откуда можно считывать или помещать данные. То есть одна горутина может отправить данные в канал, а другая — считать помещенные в этот канал данные.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"sozdanie-kanala\"\u003EСоздание канала\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EGo для создания канала предоставляет ключевое слово chan. Канал может передавать данные только одного типа, данные других типов через это канал передавать невозможно.\u003C\u002Fp\u003E\u003Ca name=\"habracut\"\u003E\u003C\u002Fa\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"go\"\u003Epackage main\n\nimport \"fmt\"\n\nfunc main() {\n    var c chan int\n    fmt.Println(c)\n} \u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fplay.golang.org\u002Fp\u002FiWOFLfcgfF-\" rel=\"nofollow\"\u003EПример в play.golang.org\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПрограмма выше создает канал \u003Ccode\u003Ec\u003C\u002Fcode\u003E, который будет передавать \u003Ccode\u003Eint\u003C\u002Fcode\u003E. Данная программа выведет \u003Ccode\u003E&lt;nil\u003E\u003C\u002Fcode\u003E, потому что нулевое значение канала — это \u003Ccode\u003Enil\u003C\u002Fcode\u003E. Такой канал абсолютно бесполезен. Вы не можете передать или получить данные из канала, так как он не был создан (инициализирован). Для его создания необходимо использовать \u003Ccode\u003Emake\u003C\u002Fcode\u003E. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"go\"\u003Epackage main\n\nimport \"fmt\"\n\nfunc main() {\n    c := make(chan int)\n\n    fmt.Printf(\"type of `c` is %T\\n\", c)\n    fmt.Printf(\"value of `c` is %v\\n\", c)\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fplay.golang.org\u002Fp\u002FN4dU7Ql9bK7\" rel=\"nofollow\"\u003EПример в play.golang.org\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ данном примере используется короткий синтаксис \u003Ccode\u003E:=\u003C\u002Fcode\u003E для создания канала с использованием функции \u003Ccode\u003Emake\u003C\u002Fcode\u003E. Программа выше выводит следующий результат:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003Etype of `c` is chan int\nvalue of `c` is 0xc0420160c0\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EОбратите внимание на значение переменной \u003Ccode\u003Ec\u003C\u002Fcode\u003E, это адрес в памяти. В go каналы являются указателями. В большинстве своем, когда вам необходимо взаимодействовать с горутиной, вы помещаете канал как аргумент в функцию или метод. Горутина получает этот канал как аргумент, и вам не нужно разыменовывать его для того, чтобы извлечь или передать данные через этот канал.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"zapis-i-chtenie-dannyh\"\u003EЗапись и чтение данных\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EGo предоставляет простой синтаксис для чтения \u003Ccode\u003E&lt;-\u003C\u002Fcode\u003E и записи в канал\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003Ec &lt;- data\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ этом примере мы передаем данные в канал \u003Ccode\u003Ec\u003C\u002Fcode\u003E. Направление стрелки указывает на то, что мы извлекаем данные из \u003Ccode\u003Edata\u003C\u002Fcode\u003E и помещаем в канал \u003Ccode\u003Ec\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003E&lt;- c\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EА здесь мы считываем данные с канала \u003Ccode\u003Ec\u003C\u002Fcode\u003E. Эта операция не сохраняет данные в переменную и она является корректной. Если вам необходимо сохранить данные с канала в переменную, вы можете использовать следующий синтаксис:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003Evar data int\ndata = &lt;- c\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТеперь данные из канала \u003Ccode\u003Ec\u003C\u002Fcode\u003E, который имеет тип \u003Ccode\u003Eint\u003C\u002Fcode\u003E, могут быть записаны в переменную \u003Ccode\u003Edata\u003C\u002Fcode\u003E. Так же можно упростить запись, используя короткий синтаксис:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003Edata := &lt;- c\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EGo определит тип данных, передаваемый каналу \u003Ccode\u003Ec\u003C\u002Fcode\u003E, и предоставит \u003Ccode\u003Edata\u003C\u002Fcode\u003E корректный тип данных.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВсе вышеобозначенные операции с каналом являются блокируемыми. Когда вы помещаете данные в канал, горутина блокируется до тех пор, пока данные не будут считаны другой горутиной из этого канала. В то же время операции канала говорят планировщику о планировании другой горутины, поэтому программа не будет заблокирована полностью. Эти функции весьма полезны, так как отпадает необходимость писать блокировки для взаимодействия горутин.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"kanaly-na-praktike\"\u003EКаналы на практике\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"go\"\u003Epackage main\n\nimport \"fmt\"\n\nfunc greet(c chan string) {\n    fmt.Println(\"Hello \" + &lt;-c + \"!\")\n}\n\nfunc main() {\n    fmt.Println(\"main() started\")\n    c := make(chan string)\n\n    go greet(c)\n\n    c &lt;- \"John\"\n    fmt.Println(\"main() stopped\")\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fplay.golang.org\u002Fp\u002FOeYLKEz7qKi\" rel=\"nofollow\"\u003EПример в play.golang.org\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EРазберем программу по шагам:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Col\u003E\r\n\u003Cli\u003EМы объявили функцию \u003Ccode\u003Egreet\u003C\u002Fcode\u003E, которая принимает канал \u003Ccode\u003Ec\u003C\u002Fcode\u003E как аргумент. В этой функции мы считываем данные из канала \u003Ccode\u003Ec\u003C\u002Fcode\u003E и выводим в консоль.\u003C\u002Fli\u003E\r\n\u003Cli\u003EВ функции \u003Ccode\u003Emain\u003C\u002Fcode\u003E программа сначала выводит \u003Ccode\u003E\"main() started\"\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\r\n\u003Cli\u003EЗатем мы, используя \u003Ccode\u003Emake\u003C\u002Fcode\u003E, создаем канал \u003Ccode\u003Ec\u003C\u002Fcode\u003E с типом даных \u003Ccode\u003Estring\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\r\n\u003Cli\u003EПомещаем канал \u003Ccode\u003Eс\u003C\u002Fcode\u003E в функцию \u003Ccode\u003Egreet\u003C\u002Fcode\u003E и запускаем функцию как горутину, используя ключевое слово \u003Ccode\u003Ego\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\r\n\u003Cli\u003EТеперь у нас имеется две горутины \u003Ccode\u003Emain\u003C\u002Fcode\u003E и \u003Ccode\u003Egreet\u003C\u002Fcode\u003E, \u003Ccode\u003Emain\u003C\u002Fcode\u003E по-прежнему остается активной.\u003C\u002Fli\u003E\r\n\u003Cli\u003EПомещаем данные в канал \u003Ccode\u003Eс\u003C\u002Fcode\u003E и в этот момент \u003Ccode\u003Emain\u003C\u002Fcode\u003E блокируется до тех пор, пока другая горутина (\u003Ccode\u003Egreet\u003C\u002Fcode\u003E) не считает данные из канала \u003Ccode\u003Ec\u003C\u002Fcode\u003E. Планировщик Go планирует запуск \u003Ccode\u003Egreet\u003C\u002Fcode\u003E и выполняет описанное в первом пункте.\u003C\u002Fli\u003E\r\n\u003Cli\u003EПосле чего \u003Ccode\u003Emain\u003C\u002Fcode\u003E снова становится активной и выводит в консоль \u003Ccode\u003E\"main() stopped\"\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\r\n\u003C\u002Fol\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"deadlock-vzaimnaya-blokirovka\"\u003EDeadlock (Взаимная блокировка)\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКак уже ранее говорилось, чтение или запись данных в канал блокирует горутину и контроль передается свободной горутине. Представим, что такие горутины отсутствуют, либо они все \"спят\". В этот момент возникает deadlock, который приведет к аварийному завершению программы.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003EЕсли вы попытаетесь считать данные из канала, но в канале будут отсутствовать данные, планировщик заблокирует текущую горутину и разблокирует другую в надежде, что какая-либо горутина передаст данные в канал. То же самое произойдет в случае отправки данных: планировщик заблокирует передающую горутину, пока другая не считает данные из канала.\u003C\u002Fblockquote\u003E\u003Cp\u003EПримером deadlock может быть \u003Ccode\u003Emain\u003C\u002Fcode\u003E горутина, которая эксклюзивно производит операции с каналом.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"go\"\u003Epackage main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"main() started\")\n\n    c := make(chan string)\n    c &lt;- \"John\"\n\n    fmt.Println(\"main() stopped\")\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fplay.golang.org\u002Fp\u002F2KTEoljdci_f\" rel=\"nofollow\"\u003EПример в play.golang.org\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПрограмма выше выведет следующее при попытке ее исполнить:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003Emain() started\nfatal error: all goroutines are asleep - deadlock!\ngoroutine 1 [chan send]:\nmain.main()\n        program.go:10 +0xfd\nexit status 2\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3 id=\"zakrytie-kanala\"\u003EЗакрытие канала\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ Go так же можно закрыть канал, через закрытый канал невозможно будет передать или принять данные. Горутина может проверить закрыт канал или нет, используя следующую конструкцию: \u003Ccode\u003Eval, ok := &lt;- channel\u003C\u002Fcode\u003E, где ok будет истиной в случае, если канал открыт или операция чтения может быть выполнена, иначе \u003Ccode\u003Eok\u003C\u002Fcode\u003E будет \u003Ccode\u003Efalse\u003C\u002Fcode\u003E, если канал закрыт и отсутствуют данных для чтения из него. Закрыть канал можно, используя встроенную функцию \u003Ccode\u003Eclose\u003C\u002Fcode\u003E, используя следующий синтаксис \u003Ccode\u003Eclose(channel)\u003C\u002Fcode\u003E. Давайте рассмотрим следующий пример:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"go\"\u003Epackage main\n\nimport \"fmt\"\n\nfunc greet(c chan string) {\n    &lt;-c \u002F\u002F for John\n    &lt;-c \u002F\u002F for Mike\n}\n\nfunc main() {\n    fmt.Println(\"main() started\")\n\n    c := make(chan string, 1)\n\n    go greet(c)\n    c &lt;- \"John\"\n\n    close(c) \u002F\u002F closing channel\n\n    c &lt;- \"Mike\"\n    fmt.Println(\"main() stopped\")\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fplay.golang.org\u002Fp\u002FLMmAq4sgm02\" rel=\"nofollow\"\u003EПример в play.golang.org\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003EДля понимания концепта блокировки первая операция отправки \u003Ccode\u003Ec &lt;- \"John\"\u003C\u002Fcode\u003E будет блокирующей, и другая горутина должна будет считать данные из канала, следовательно \u003Ccode\u003Egreet\u003C\u002Fcode\u003E горутина будет запланирована планировщиком. Затем первая операция чтения будет неблокируемой, поскольку присутствуют данные для чтения в канале \u003Ccode\u003Ec\u003C\u002Fcode\u003E. Вторая операция чтения будет блокируемой, потому что в канале \u003Ccode\u003Ec\u003C\u002Fcode\u003E отсутствуют данные, поэтому планировщик переключится на \u003Ccode\u003Emain\u003C\u002Fcode\u003E горутину и программа выполнит закрытие канала \u003Ccode\u003Eclose(c)\u003C\u002Fcode\u003E.\u003C\u002Fblockquote\u003E\u003Cp\u003EВывод программы:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003Emain() started\npanic: send on closed channel\n\ngoroutine 1 [running]:\nmain.main()\n    program.go:20 +0x120\nexit status 2\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКак вы можете заметить, программа завершилась с ошибкой, которая говорит, что запись в закрытый канал невозможна. Для дальнейшего понимания закрытия каналов давайте рассмотрим пример с циклом \u003Ccode\u003Efor\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3 id=\"primer-s-ciklom-for\"\u003EПример с циклом for\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"go\"\u003Epackage main\n\nimport \"fmt\"\n\nfunc squares(c chan int) {\n    for i := 0; i &lt;= 9; i++ {\n        c &lt;- i * i\n    }\n\n    close(c) \u002F\u002F close channel\n}\n\nfunc main() {\n    fmt.Println(\"main() started\")\n    c := make(chan int)\n\n    go squares(c) \u002F\u002F start goroutine\n\n    \u002F\u002F periodic block\u002Funblock of main goroutine until chanel closes\n    for {\n        val, ok := &lt;-c\n        if ok == false {\n            fmt.Println(val, ok, \"&lt;-- loop broke!\")\n            break \u002F\u002F exit break loop\n        } else {\n            fmt.Println(val, ok)\n        }\n    }\n\n    fmt.Println(\"main() stopped\")\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fplay.golang.org\u002Fp\u002FX58FTgSHhXi\" rel=\"nofollow\"\u003EПример в play.golang.org\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EБесконечный цикл может быть полезен для чтения данных из канала, когда мы не знаем сколько данных мы ожидаем. В этом примере мы создаем горутину \u003Ccode\u003Esquares\u003C\u002Fcode\u003E, которая последовательно возвращает квадраты чисел от 0 до 9. В \u003Ccode\u003Emain\u003C\u002Fcode\u003E мы считываем эти числа внутри цикла \u003Ccode\u003Efor\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ цикле мы считываем данные из канала, используя ранее рассмотренный синтаксис \u003Ccode\u003Eval, ok := &lt;-c\u003C\u002Fcode\u003E, где \u003Ccode\u003Eok\u003C\u002Fcode\u003E предоставляет нам информацию о том, что канал закрыт. В горутине \u003Ccode\u003Esquares\u003C\u002Fcode\u003E после того, как записали все данные, мы закрываем канал, используя функцию \u003Ccode\u003Eclose\u003C\u002Fcode\u003E. Когда \u003Ccode\u003Eok\u003C\u002Fcode\u003E будет \u003Ccode\u003Etrue\u003C\u002Fcode\u003E, программа выведет значение \u003Ccode\u003Eval\u003C\u002Fcode\u003E и статус канала (переменная \u003Ccode\u003Eok\u003C\u002Fcode\u003E). Когда \u003Ccode\u003Eok\u003C\u002Fcode\u003E станет \u003Ccode\u003Efalse\u003C\u002Fcode\u003E, мы завершим цикл, используя ключевое слово \u003Ccode\u003Ebreak\u003C\u002Fcode\u003E. Таким образом мы получим следующий результат:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003Emain() started\n0 true\n1 true\n4 true\n9 true\n16 true\n25 true\n36 true\n49 true\n64 true\n81 true\n0 false &lt;-- loop broke!\nmain() stopped\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003EКогда канал закрыт, значение \u003Ccode\u003Eval\u003C\u002Fcode\u003E, считанное горутиной, является нулевым значением, в зависимости от типа данных канала. Так как в нашем случае тип данных канала \u003Ccode\u003Eint\u003C\u002Fcode\u003E, то нулевое значение будет 0, как раз это мы и видим в этой строке: \u003Ccode\u003E0 false &lt;-- loop broke!\u003C\u002Fcode\u003E\u003C\u002Fblockquote\u003E\u003Cp\u003EДля того, чтобы избежать столь громоздкой проверки закрытия канала в случае цикла \u003Ccode\u003Efor\u003C\u002Fcode\u003E, Go предоставляет ключевое слово \u003Ccode\u003Erange\u003C\u002Fcode\u003E, которое автоматически останавливает цикл, когда канал будет закрыт. Давайте перепишем нашу программу с использованием \u003Ccode\u003Erange\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"go\"\u003Epackage main\n\nimport \"fmt\"\n\nfunc squares(c chan int) {\n    for i := 0; i &lt;= 9; i++ {\n        c &lt;- i * i\n    }\n\n    close(c) \u002F\u002F close channel\n}\n\nfunc main() {\n    fmt.Println(\"main() started\")\n    c := make(chan int)\n\n    go squares(c) \u002F\u002F start goroutine\n\n    \u002F\u002F periodic block\u002Funblock of main goroutine until chanel closes\n    for val := range c {\n        fmt.Println(val)\n    }\n\n    fmt.Println(\"main() stopped\")\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fplay.golang.org\u002Fp\u002FICCYbWO7ZvD\" rel=\"nofollow\"\u003EПример в play.golang.org\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ этом примере мы использовали \u003Ccode\u003Eval := range c\u003C\u002Fcode\u003E вместо бесконечного цикла, где \u003Ccode\u003Erange\u003C\u002Fcode\u003E будет считывать данные из канала до тех пор, пока канал не будет закрыт. В результате программа выведет следующее:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003Emain() started\n0\n1\n4\n9\n16\n25\n36\n49\n64\n81\nmain() stopped\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003EЕсли вы не закроете канал для цикла \u003Ccode\u003Efor\u003C\u002Fcode\u003E с использованием \u003Ccode\u003Erange\u003C\u002Fcode\u003E, то программа будет завершена аварийно из-за \u003Ccode\u003Edealock\u003C\u002Fcode\u003E во время выполнения.\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3 id=\"razmer-bufera-kanala\"\u003EРазмер буфера канала\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКак вы уже заметили, каждая операция отправки данных в канал блокирует текущую горутину. Но мы еще не использовали функцию \u003Ccode\u003Emake\u003C\u002Fcode\u003E с 2-мя аргументами. Второй аргумент — это размер буфера канала. По-умолчанию размер буфера канала равен 0, такой канал называется небуферизированным каналом. То есть все, что мы пишем в канал, сразу доступно для чтения.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКогда размер буфера больше 0, горутина не блокируется до тех пор, пока буфер не будет заполнен. Когда буфер заполнен, любые значения отправляемые через канал, добавляются к буферу, отбрасывая предыдущее значение, которое доступно для чтения (где горутина будет заблокирована). Но есть один подвох, операция чтения на буферизированном канале является жадной, таким образом, как только операция чтения началась, она не будет завершена до полного опустошения буфера. Это означает, что горутина будет считывать буфер канала без блокировки до тех пор, пока буфер не станет пустым.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДля объявления буферизированного канала мы можем использовать следующий синтаксис:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003Ec := make(chan Type, n)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЭто выражение создаст канал с типом данных \u003Ccode\u003EType\u003C\u002Fcode\u003E и размером буфера \u003Ccode\u003En\u003C\u002Fcode\u003E. Текущая горутина не будет заблокирована, пока в канал не будет передано n+1 данных.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДавайте докажем, что горутина не блокируется, пока буфер не заполнится и не переполнится:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"go\"\u003Epackage main\n\nimport \"fmt\"\n\nfunc squares(c chan int) {\n    for i := 0; i &lt;= 3; i++ {\n        num := &lt;-c\n        fmt.Println(num * num)\n    }\n}\n\nfunc main() {\n    fmt.Println(\"main() started\")\n    c := make(chan int, 3)\n\n    go squares(c)\n\n    c &lt;- 1\n    c &lt;- 2\n    c &lt;- 3\n\n    fmt.Println(\"main() stopped\")\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fplay.golang.org\u002Fp\u002Fk0usdYZfp3D\" rel=\"nofollow\"\u003EПример в play.golang.org\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ этом примере канал \u003Ccode\u003Ec\u003C\u002Fcode\u003E имеет размер буфера равным 3. Это означает, что он может содержать 3 значения(\u003Ccode\u003Ec &lt;- 3\u003C\u002Fcode\u003E), но поскольку буфер не переполняется (так как мы не поместили новое значение в буфер), \u003Ccode\u003Emain\u003C\u002Fcode\u003E не будет блокироваться, и программа будет успешно завершена без вывода чисел. Вывод программы:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003Emain() started\nmain() stopped\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТеперь давайте поместим еще одно значение в канал:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"go\"\u003Epackage main\n\nimport \"fmt\"\n\nfunc squares(c chan int) {\n    for i := 0; i &lt;= 3; i++ {\n        num := &lt;-c\n        fmt.Println(num * num)\n    }\n}\n\nfunc main() {\n    fmt.Println(\"main() started\")\n    c := make(chan int, 3)\n\n    go squares(c)\n\n    c &lt;- 1\n    c &lt;- 2\n    c &lt;- 3\n    c &lt;- 4 \u002F\u002F blocks here\n\n    fmt.Println(\"main() stopped\")\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fplay.golang.org\u002Fp\u002FKGyiskRj1Wi\" rel=\"nofollow\"\u003EПример в play.golang.org\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКак упоминалось ранее, теперь мы помещаем дополнительное значение в буфер и \u003Ccode\u003Emain\u003C\u002Fcode\u003E блокируется, затем стартует горутина \u003Ccode\u003Esquares\u003C\u002Fcode\u003E, которая вычитывает все значения из буфера, пока он не станет пустым.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"dlina-i-emkost-kanala\"\u003EДлина и емкость канала\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПодобно срезам, буферизированный канал имеет длину и емкость. Длина канала — это количество значений в очереди (не считанных) в буфере канала, емкость — это размер самого буфера канала. Для того, чтобы вычислить длину, мы используем функцию \u003Ccode\u003Elen\u003C\u002Fcode\u003E, а, используя функцию \u003Ccode\u003Ecap\u003C\u002Fcode\u003E, получаем размер буфера.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003Epackage main\n\nimport \"fmt\"\n\nfunc main() {\n    c := make(chan int, 3)\n    c &lt;- 1\n    c &lt;- 2\n\n    fmt.Printf(\"Length of channel c is %v and capacity of channel c is %v\", len(c), cap(c))\n    fmt.Println()\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fplay.golang.org\u002Fp\u002FqsDZu6pXLT7\" rel=\"nofollow\"\u003EПример в play.golang.org\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВывод программы:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003ELength of channel c is 2 and capacity of channel c is 3\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВышеприведенная программа работает нормально и \u003Ccode\u003Edeadlock\u003C\u002Fcode\u003E не возникает, потому что размер буфера канала равен 3, а мы записали только 2 значения в буфер, поэтому планировщик не попытался запланировать другую горутину и не заблокировал \u003Ccode\u003Emain\u003C\u002Fcode\u003E. Вы даже можете считать эти данные в \u003Ccode\u003Emain\u003C\u002Fcode\u003E, если вам это необходимо, потому что \u003Cstrong\u003Eбуфер не заполнен\u003C\u002Fstrong\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДругой пример:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"go\"\u003Epackage main\n\nimport \"fmt\"\n\nfunc sender(c chan int) {\n    c &lt;- 1 \u002F\u002F len 1, cap 3\n    c &lt;- 2 \u002F\u002F len 2, cap 3\n    c &lt;- 3 \u002F\u002F len 3, cap 3\n    c &lt;- 4 \u002F\u002F &lt;- goroutine blocks here\n    close(c)\n}\n\nfunc main() {\n    c := make(chan int, 3)\n\n    go sender(c)\n\n    fmt.Printf(\"Length of channel c is %v and capacity of channel c is %v\\n\", len(c), cap(c))\n\n    \u002F\u002F read values from c (blocked here)\n    for val := range c {\n        fmt.Printf(\"Length of channel c after value '%v' read is %v\\n\", val, len(c))\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fplay.golang.org\u002Fp\u002F-gGpm08-wzz\" rel=\"nofollow\"\u003EПример в play.golang.org\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВывод программы:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003ELength of channel c is 0 and capacity of channel c is 3\nLength of channel c after value '1' read is 3\nLength of channel c after value '2' read is 2\nLength of channel c after value '3' read is 1\nLength of channel c after value '4' read is 0\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДополнительный пример с буферизированным каналом:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"go\"\u003Epackage main\n\nimport (\n    \"fmt\"\n    \"runtime\"\n)\n\nfunc squares(c chan int) {\n    for i := 0; i &lt; 4; i++ {\n        num := &lt;-c\n        fmt.Println(num * num)\n    }\n}\n\nfunc main() {\n    fmt.Println(\"main() started\")\n    c := make(chan int, 3)\n    go squares(c)\n\n    fmt.Println(\"active goroutines\", runtime.NumGoroutine())\n    c &lt;- 1\n    c &lt;- 2\n    c &lt;- 3\n    c &lt;- 4 \u002F\u002F blocks here\n\n    fmt.Println(\"active goroutines\", runtime.NumGoroutine())\n\n    go squares(c)\n\n    fmt.Println(\"active goroutines\", runtime.NumGoroutine())\n\n    c &lt;- 5\n    c &lt;- 6\n    c &lt;- 7\n    c &lt;- 8 \u002F\u002F blocks here\n\n    fmt.Println(\"active goroutines\", runtime.NumGoroutine())\n    fmt.Println(\"main() stopped\")\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fplay.golang.org\u002Fp\u002FsdHPDx64aor\" rel=\"nofollow\"\u003EПример в play.golang.org\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВывод программы:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003Emain() started\nactive goroutines 2\n1\n4\n9\n16\nactive goroutines 1\nactive goroutines 2\n25\n36\n49\n64\nactive goroutines 1\nmain() stopped\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИспользуя буферизованный канал и цикл \u003Ccode\u003Efor range\u003C\u002Fcode\u003E, мы можем читать с закрытых каналов. Поскольку у закрытых каналов данные все еще живут в буфере, их можно считать:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"go\"\u003Epackage main\n\nimport \"fmt\"\n\nfunc main() {\n    c := make(chan int, 3)\n    c &lt;- 1\n    c &lt;- 2\n    c &lt;- 3\n    close(c)\n\n    \u002F\u002F iteration terminates after receiving 3 values\n    for elem := range c {\n        fmt.Println(elem)\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fplay.golang.org\u002Fp\u002FvULFyWnpUoj\" rel=\"nofollow\"\u003EПример в play.golang.org\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"rabota-s-neskolkimi-gorutinami\"\u003EРабота с несколькими горутинами\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДавайте напишем 2 горутины, одна для вычисления квадрата целого числа, а другая для вычисления куба:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"go\"\u003Epackage main\n\nimport \"fmt\"\n\nfunc square(c chan int) {\n    fmt.Println(\"[square] reading\")\n    num := &lt;-c\n    c &lt;- num * num\n}\n\nfunc cube(c chan int) {\n    fmt.Println(\"[cube] reading\")\n    num := &lt;-c\n    c &lt;- num * num * num\n}\n\nfunc main() {\n    fmt.Println(\"[main] main() started\")\n\n    squareChan := make(chan int)\n    cubeChan := make(chan int)\n\n    go square(squareChan)\n    go cube(cubeChan)\n\n    testNum := 3\n    fmt.Println(\"[main] sent testNum to squareChan\")\n\n    squareChan &lt;- testNum\n\n    fmt.Println(\"[main] resuming\")\n    fmt.Println(\"[main] sent testNum to cubeChan\")\n\n    cubeChan &lt;- testNum\n\n    fmt.Println(\"[main] resuming\")\n    fmt.Println(\"[main] reading from channels\")\n\n    squareVal, cubeVal := &lt;-squareChan, &lt;-cubeChan\n    sum := squareVal + cubeVal\n\n    fmt.Println(\"[main] sum of square and cube of\", testNum, \" is\", sum)\n    fmt.Println(\"[main] main() stopped\")\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fplay.golang.org\u002Fp\u002F6wdhWYpRfrX\" rel=\"nofollow\"\u003EПример в play.golang.org\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EРазберем программу по шагам:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Col\u003E\r\n\u003Cli\u003EМы создали 2 функции \u003Ccode\u003Esquare\u003C\u002Fcode\u003E и \u003Ccode\u003Ecube\u003C\u002Fcode\u003E, которые мы запускаем как горутины. Обе получают канал \u003Ccode\u003Ec\u003C\u002Fcode\u003E c типом данных \u003Ccode\u003Eint\u003C\u002Fcode\u003E, и считывают данные из него в переменную \u003Ccode\u003Enum\u003C\u002Fcode\u003E. Затем мы пишем данные в канал \u003Ccode\u003Ec\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\r\n\u003Cli\u003EВ \u003Ccode\u003Emain\u003C\u002Fcode\u003E горутине мы создаем два канала \u003Ccode\u003EsquareChan\u003C\u002Fcode\u003E и \u003Ccode\u003EcubeChan\u003C\u002Fcode\u003E c типом данных \u003Ccode\u003Eint\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\r\n\u003Cli\u003EЗапускаем \u003Ccode\u003Esquare\u003C\u002Fcode\u003E и \u003Ccode\u003Ecube\u003C\u002Fcode\u003E горутины.\u003C\u002Fli\u003E\r\n\u003Cli\u003EТак как контроль по-прежнему внутри \u003Ccode\u003Emain\u003C\u002Fcode\u003E \u003Ccode\u003EtestNum\u003C\u002Fcode\u003E получает значение 3.\u003C\u002Fli\u003E\r\n\u003Cli\u003EЗатем мы отправляем данные в канал \u003Ccode\u003EsquareChan\u003C\u002Fcode\u003E и \u003Ccode\u003EcubeChan\u003C\u002Fcode\u003E. Горутина \u003Ccode\u003Emain\u003C\u002Fcode\u003E будет заблокирована, пока данные из каналов не будут считаны. Как только значение будет считано, горутина снова станет активной.\u003C\u002Fli\u003E\r\n\u003Cli\u003EКогда в \u003Ccode\u003Emain\u003C\u002Fcode\u003E мы попытаемся прочитать данные из заданных каналов(\u003Ccode\u003EsquareChan\u003C\u002Fcode\u003E и \u003Ccode\u003EcubeChan\u003C\u002Fcode\u003E), управление будет заблокировано, пока другие горутины (\u003Ccode\u003Esquare\u003C\u002Fcode\u003E и \u003Ccode\u003Ecube\u003C\u002Fcode\u003E) не запишут данные в эти каналы. Мы также использовали сокращенный синтаксис \u003Ccode\u003E:=\u003C\u002Fcode\u003E для получения данных из каналов.\u003C\u002Fli\u003E\r\n\u003Cli\u003EКогда операция записи канала завершена, начинает выполняться \u003Ccode\u003Emain\u003C\u002Fcode\u003E, после чего мы рассчитываем сумму и выводим ее.\u003C\u002Fli\u003E\r\n\u003C\u002Fol\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EРезультат выполнения программы:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003E[main] main() started\n[main] sent testNum to squareChan\n[cube] reading\n[square] reading\n[main] resuming\n[main] sent testNum to cubeChan\n[main] resuming\n[main] reading from channels\n[main] sum of square and cube of 3  is 36\n[main] main() stopped\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3 id=\"odnonapravlennye-kanaly\"\u003EОднонаправленные каналы\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДо сих пор мы видели каналы, которые могут передавать и принимать данные. Но мы также можем создать канал, который будет однонаправленным. Например, канал, который сможет только считывать данные, и канал который сможет только записывать их.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EОднонаправленный канал также создается с использованием \u003Ccode\u003Emake\u003C\u002Fcode\u003E, но с дополнительным стрелочным синтаксисом.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003Eroc := make(&lt;-chan int)\nsoc := make(chan&lt;- int)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EГде \u003Ccode\u003Eroc\u003C\u002Fcode\u003E канал для чтения, а \u003Ccode\u003Esoc\u003C\u002Fcode\u003E канал для записи. Следует заметить, что каналы также имеют разный тип.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"go\"\u003Epackage main\n\nimport \"fmt\"\n\nfunc main() {\n    roc := make(&lt;-chan int)\n    soc := make(chan&lt;- int)\n\n    fmt.Printf(\"Data type of roc is `%T`\\n\", roc)\n    fmt.Printf(\"Data type of soc is `%T\\n\", soc)\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fplay.golang.org\u002Fp\u002FJZO51IoaMg8\" rel=\"nofollow\"\u003EПример в play.golang.org\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВывод программы:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003EData type of roc is `&lt;-chan int`\nData type of soc is `chan&lt;- int\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНо в чем смысл использования однонаправленного канала? Использование однонаправленного канала улучшает безопасность типов в программe, что, как следствие, порождает меньше ошибок.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНо допустим, что у вас есть программа, в которой вам нужно только читать данные из канала, а основная программа должна иметь возможность читать и записывать данные из\u002Fв тот же канал. Как это будет работать?\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EК счастью Go предоставляет простой синтаксис для преобразования двунаправленного канала в однонаправленный канал.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"go\"\u003Eimport \"fmt\"\n\nfunc greet(roc &lt;-chan string) {\n    fmt.Println(\"Hello \" + &lt;-roc + \"!\")\n}\n\nfunc main() {\n    fmt.Println(\"main() started\")\n    c := make(chan string)\n\n    go greet(c)\n\n    c &lt;- \"John\"\n    fmt.Println(\"main() stopped\")\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fplay.golang.org\u002Fp\u002Fk3B3gCelrGv\" rel=\"nofollow\"\u003EПример в play.golang.org\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EМы только что изменили параметры \u003Ccode\u003Egreet\u003C\u002Fcode\u003E для того, чтобы преобразовать двунаправленный канал на канал для чтения данных. Теперь мы можем только считывать данные из этого канала, а любые операции чтения приведут к аварийному завершению программы со следующей ошибкой:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ccode\u003E\"invalid operation: roc &lt;- \"some text\" (send to receive-only type &lt;-chan string)\"\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3 id=\"anonimnye-gorutiny\"\u003EАнонимные горутины\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКаналы также могут работать и с анонимными горутинами. Давайте изменим предыдущий пример, используя анонимные горутины.\u003Cbr\u002F\u003E\r\nВот что у нас получилось:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"go\"\u003Epackage main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"main() started\")\n    c := make(chan string)\n\n    \u002F\u002F launch anonymous goroutine\n    go func(c chan string) {\n        fmt.Println(\"Hello \" + &lt;-c + \"!\")\n    }(c)\n\n    c &lt;- \"John\"\n    fmt.Println(\"main() stopped\")\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fplay.golang.org\u002Fp\u002FcM5nFgRha7c\" rel=\"nofollow\"\u003EПример в play.golang.org\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКак вы можете заметить вывод программы остался тот же самый.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3 id=\"kanal-s-tipom-dannyh-kanala\"\u003EКанал с типом данных канала\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКаналы являются \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002F%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82_%D0%BF%D0%B5%D1%80%D0%B2%D0%BE%D0%B3%D0%BE_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0\" rel=\"nofollow\"\u003Eобъектами первого класса\u003C\u002Fa\u003E, то есть они могут быть использованы как значение элемента структуры, или аргументы функции, как возврат значения из функции\u002Fметода и даже как тип для другого канала. В примере ниже мы используем канал в качестве типа данных для другого канала:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"go\"\u003Epackage main\n\nimport \"fmt\"\n\n\u002F\u002F gets a channel and prints the greeting by reading from channel\nfunc greet(c chan string) {\n    fmt.Println(\"Hello \" + &lt;-c + \"!\")\n}\n\n\u002F\u002F gets a channels and writes a channel to it\nfunc greeter(cc chan chan string) {\n    c := make(chan string)\n    cc &lt;- c\n}\n\nfunc main() {\n    fmt.Println(\"main() started\")\n\n    \u002F\u002F make a channel `cc` of data type channel of string data type\n    cc := make(chan chan string)\n\n    go greeter(cc) \u002F\u002F start `greeter` goroutine using `cc` channel\n\n    \u002F\u002F receive a channel `c` from `greeter` goroutine\n    c := &lt;-cc\n\n    go greet(c) \u002F\u002F start `greet` goroutine using `c` channel\n\n    \u002F\u002F send data to `c` channel\n    c &lt;- \"John\"\n\n    fmt.Println(\"main() stopped\")\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fplay.golang.org\u002Fp\u002FxVQvvb8O4De\" rel=\"nofollow\"\u003EПример в play.golang.org\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3 id=\"select\"\u003Eselect\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ccode\u003Eselect\u003C\u002Fcode\u003E похож на \u003Ccode\u003Eswitch\u003C\u002Fcode\u003E без аргументов, но он может использоваться только для операций с каналами. Оператор \u003Ccode\u003Eselect\u003C\u002Fcode\u003E используется для выполнения операции только с одним из множества каналов, условно выбранного блоком case.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДавай взглянем на пример ниже, и обсудим как он работает:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"go\"\u003Epackage main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nvar start time.Time\nfunc init() {\n    start = time.Now()\n}\n\nfunc service1(c chan string) {\n    time.Sleep(3 * time.Second)\n    c &lt;- \"Hello from service 1\"\n}\n\nfunc service2(c chan string) {\n    time.Sleep(5 * time.Second)\n    c &lt;- \"Hello from service 2\"\n}\n\nfunc main() {\n    fmt.Println(\"main() started\", time.Since(start))\n\n    chan1 := make(chan string)\n    chan2 := make(chan string)\n\n    go service1(chan1)\n    go service2(chan2)\n\n    select {\n    case res := &lt;-chan1:\n        fmt.Println(\"Response from service 1\", res, time.Since(start))\n    case res := &lt;-chan2:\n        fmt.Println(\"Response from service 2\", res, time.Since(start))\n    }\n\n    fmt.Println(\"main() stopped\", time.Since(start))\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fplay.golang.org\u002Fp\u002Far5dZUQ2ArH\" rel=\"nofollow\"\u003EПример в play.golang.org\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ этом примере мы используем оператор \u003Ccode\u003Eselect\u003C\u002Fcode\u003E как \u003Ccode\u003Eswitch\u003C\u002Fcode\u003E, но вместо булевых операций, мы используем операции для чтения данных из канала. Оператор \u003Ccode\u003Eselect\u003C\u002Fcode\u003E также является блокируемым, за исключением использования \u003Ccode\u003Edefault\u003C\u002Fcode\u003E(позже вы увидите пример с его использованием). После выполнения одного из блоков \u003Ccode\u003Ecase\u003C\u002Fcode\u003E, горутина \u003Ccode\u003Emain\u003C\u002Fcode\u003E будет разблокирована. Задались вопросом когда \u003Ccode\u003Ecase\u003C\u002Fcode\u003E условие выполнится?\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЕсли все блоки \u003Ccode\u003Ecase\u003C\u002Fcode\u003E являются блокируемыми, тогда \u003Ccode\u003Eselect\u003C\u002Fcode\u003E будет ждать до момента, пока один из блоков \u003Ccode\u003Ecase\u003C\u002Fcode\u003E разблокируется и будет выполнен. Если несколько или все канальные операции не блокируемы, тогда один из неблокируемых \u003Ccode\u003Ecase\u003C\u002Fcode\u003E будет выбран случайным образом (Примечание переводчика: имеется ввиду случай, когда пришли одновременно данные из двух и более каналов).\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДавайте наконец разберем программу, которую написали ранее. Мы запустили 2 горутины с независимыми каналами. Затем мы использовали оператор \u003Ccode\u003Eselect\u003C\u002Fcode\u003E c двумя \u003Ccode\u003Ecase\u003C\u002Fcode\u003E операторами. Один \u003Ccode\u003Ecase\u003C\u002Fcode\u003E считывает данные из \u003Ccode\u003Echan1\u003C\u002Fcode\u003E а другой из \u003Ccode\u003Echan2\u003C\u002Fcode\u003E. Так как каналы не используют буфер, операция чтения будет блокируемой. Таким образом оба \u003Ccode\u003Ecase\u003C\u002Fcode\u003E будут блокируемыми и \u003Ccode\u003Eselect\u003C\u002Fcode\u003E будет ждать до тех пор, пока один из \u003Ccode\u003Ecase\u003C\u002Fcode\u003E не разблокируется.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКогда программа находится в блоке \u003Ccode\u003Eselect\u003C\u002Fcode\u003E горутина \u003Ccode\u003Emain\u003C\u002Fcode\u003E будет заблокирована и будут запланированы все горутины (по одной за раз), которые используются в блоке \u003Ccode\u003Eselect\u003C\u002Fcode\u003E, в нашем случае это \u003Ccode\u003Eservice1\u003C\u002Fcode\u003E и \u003Ccode\u003Eservice2\u003C\u002Fcode\u003E. \u003Ccode\u003Eservice1\u003C\u002Fcode\u003E ждет 3 секунды, после чего будет разблокирован и сможет записать данные в \u003Ccode\u003Echan1\u003C\u002Fcode\u003E. Таким же образом как и \u003Ccode\u003Eservice1\u003C\u002Fcode\u003E действует \u003Ccode\u003Eservice2\u003C\u002Fcode\u003E, только он ожидает 5 секунд и осуществляет запись в \u003Ccode\u003Echan2\u003C\u002Fcode\u003E. Так как \u003Ccode\u003Eservice1\u003C\u002Fcode\u003E разблокируется раньше, чем \u003Ccode\u003Eservice2\u003C\u002Fcode\u003E, первый \u003Ccode\u003Ecase\u003C\u002Fcode\u003E разблокируется раньше и произведет чтение из \u003Ccode\u003Echan1\u003C\u002Fcode\u003E, а второй \u003Ccode\u003Ecase\u003C\u002Fcode\u003E будет проигнорирован. После чего управление вернется в \u003Ccode\u003Emain\u003C\u002Fcode\u003E, и программа завершится после вывода в консоль.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВывод программы:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003Emain() started 0s\nResponse from service 1 Hello from service 1 3s\nmain() stopped 3s\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003EВышеприведенная программа имитирует реальный веб-сервис, в котором балансировщик нагрузки получает миллионы запросов и должен возвращать ответ от одной из доступных служб. Используя стандартные горутины, каналы и select, мы можем запросить ответ у нескольких сервисов, и тот, который ответит раньше всех, может быть использован.\u003C\u002Fblockquote\u003E\u003Cp\u003EДля того, чтобы симулировать случай, когда все блоки \u003Ccode\u003Ecase\u003C\u002Fcode\u003E разблокируются в одно и тоже время, мы может просто удалить вызов Sleep из горутин.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"go\"\u003Epackage main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nvar start time.Time\nfunc init() {\n    start = time.Now()\n}\n\nfunc service1(c chan string) {\n    c &lt;- \"Hello from service 1\"\n}\n\nfunc service2(c chan string) {\n    c &lt;- \"Hello from service 2\"\n}\n\nfunc main() {\n    fmt.Println(\"main() started\", time.Since(start))\n\n    chan1 := make(chan string)\n    chan2 := make(chan string)\n\n    go service1(chan1)\n    go service2(chan2)\n\n    select {\n    case res := &lt;-chan1:\n        fmt.Println(\"Response from service 1\", res, time.Since(start))\n    case res := &lt;-chan2:\n        fmt.Println(\"Response from service 2\", res, time.Since(start))\n    }\n\n    fmt.Println(\"main() stopped\", time.Since(start))\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fplay.golang.org\u002Fp\u002FgiSkkqt8XHb\" rel=\"nofollow\"\u003EПример в play.golang.org\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДанная программа выводит следующий результат:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003Emain() started 0s\nservice2() started 481µs\nResponse from service 2 Hello from service 2 981.1µs\nmain() stopped 981.1µs\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНо иногда вы можете получить следующий результат:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003Emain() started 0s\nservice1() started 484.8µs\nResponse from service 1 Hello from service 1 984µs\nmain() stopped 984µs\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЭто происходит потому, что операции \u003Ccode\u003Echan1\u003C\u002Fcode\u003E и \u003Ccode\u003Echan2\u003C\u002Fcode\u003E выполняются практически одновременно, но все же существует некоторая разница во времени при исполнении и планировании горутин.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДля того, чтобы сделать все блоки \u003Ccode\u003Ecase\u003C\u002Fcode\u003E неблокируемыми, мы можем использовать каналы с буфером.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"go\"\u003Epackage main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nvar start time.Time\n\nfunc init() {\n    start = time.Now()\n}\n\nfunc main() {\n    fmt.Println(\"main() started\", time.Since(start))\n    chan1 := make(chan string, 2)\n    chan2 := make(chan string, 2)\n\n    chan1 &lt;- \"Value 1\"\n    chan1 &lt;- \"Value 2\"\n    chan2 &lt;- \"Value 1\"\n    chan2 &lt;- \"Value 2\"\n\n    select {\n    case res := &lt;-chan1:\n        fmt.Println(\"Response from chan1\", res, time.Since(start))\n    case res := &lt;-chan2:\n        fmt.Println(\"Response from chan2\", res, time.Since(start))\n    }\n\n    fmt.Println(\"main() stopped\", time.Since(start))\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fplay.golang.org\u002Fp\u002FRLRGEmFQP3f\" rel=\"nofollow\"\u003EПример в play.golang.org\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВывод может быть следующим:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003Emain() started 0s\nResponse from chan2 Value 1 0s\nmain() stopped 1.0012ms\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИли таким:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003Emain() started 0s\nResponse from chan1 Value 1 0s\nmain() stopped 1.0012ms\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ приведенной программе оба канала имеют буфер размером 2. Так как мы отправляем 2 значения в буфер, горутина не будет заблокирована и программа перейдет в блок \u003Ccode\u003Eselect\u003C\u002Fcode\u003E. Чтение из буферизированного канала не является блокируемой операцией, если буфер не пустой, поэтому все блоки \u003Ccode\u003Ecase\u003C\u002Fcode\u003E будут неблокируемыми, и во время выполнения Go выберет \u003Ccode\u003Ecase\u003C\u002Fcode\u003E случайным образом.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3 id=\"default-case\"\u003Edefault case\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТак же как и \u003Ccode\u003Eswitch\u003C\u002Fcode\u003E, оператор \u003Ccode\u003Eselect\u003C\u002Fcode\u003E поддерживает оператор \u003Ccode\u003Edefault\u003C\u002Fcode\u003E. Оператор \u003Ccode\u003Edefault\u003C\u002Fcode\u003E является неблокируемым, но это еще не все, оператор \u003Ccode\u003Edefault\u003C\u002Fcode\u003E делает блок \u003Ccode\u003Eselect\u003C\u002Fcode\u003E всегда неблокируемым. Это означает, что операции отправки и чтение на любом канале (не имеет значения будет ли канал с буфером или без) всегда будут неблокируемыми.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЕсли значение будет доступно на каком-либо канале, то \u003Ccode\u003Eselect\u003C\u002Fcode\u003E выполнит этот \u003Ccode\u003Ecase\u003C\u002Fcode\u003E. Если нет, то он немедленно выполнит \u003Ccode\u003Edefault\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"go\"\u003Epackage main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nvar start time.Time\n\nfunc init() {\n    start = time.Now()\n}\n\nfunc service1(c chan string) {\n    fmt.Println(\"service1() started\", time.Since(start))\n    c &lt;- \"Hello from service 1\"\n}\n\nfunc service2(c chan string) {\n    fmt.Println(\"service2() started\", time.Since(start))\n    c &lt;- \"Hello from service 2\"\n}\n\nfunc main() {\n    fmt.Println(\"main() started\", time.Since(start))\n\n    chan1 := make(chan string)\n    chan2 := make(chan string)\n\n    go service1(chan1)\n    go service2(chan2)\n\n    select {\n    case res := &lt;-chan1:\n        fmt.Println(\"Response from service 1\", res, time.Since(start))\n    case res := &lt;-chan2:\n        fmt.Println(\"Response from service 2\", res, time.Since(start))\n    default:\n        fmt.Println(\"No response received\", time.Since(start))\n    }\n\n    fmt.Println(\"main() stopped\", time.Since(start))\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fplay.golang.org\u002Fp\u002FrFMpc80EuT3\" rel=\"nofollow\"\u003EПример в play.golang.org\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВывод программы:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003Emain() started 0s\nNo response received 0s\nmain() stopped 0s\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТак как в приведенной программе каналы используются без буфера, и значение еще отсутствует, в обоих каналах будет исполнен \u003Ccode\u003Edefault\u003C\u002Fcode\u003E. Если бы в блоке \u003Ccode\u003Eselect\u003C\u002Fcode\u003E отсутствовал \u003Ccode\u003Edefault\u003C\u002Fcode\u003E, то произошла бы блокировка и результат был бы другим.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТак как с \u003Ccode\u003Edefault\u003C\u002Fcode\u003E \u003Ccode\u003Eselect\u003C\u002Fcode\u003E не блокируется, планировщик не запускает доступные горутины. Но \u003Ccode\u003Emain\u003C\u002Fcode\u003E можно заблокировать, вызвав \u003Ccode\u003Etime.Sleep\u003C\u002Fcode\u003E. Таким образом все горутины будут исполнены, и когда управление перейдет в \u003Ccode\u003Emain\u003C\u002Fcode\u003E, каналы будут иметь данные для чтения.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"go\"\u003Epackage main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nvar start time.Time\n\nfunc init() {\n    start = time.Now()\n}\n\nfunc service1(c chan string) {\n    fmt.Println(\"service1() started\", time.Since(start))\n    c &lt;- \"Hello from service 1\"\n}\n\nfunc service2(c chan string) {\n    fmt.Println(\"service2() started\", time.Since(start))\n    c &lt;- \"Hello from service 2\"\n}\n\nfunc main() {\n    fmt.Println(\"main() started\", time.Since(start))\n\n    chan1 := make(chan string)\n    chan2 := make(chan string)\n\n    go service1(chan1)\n    go service2(chan2)\n\n    time.Sleep(3 * time.Second)\n\n    select {\n    case res := &lt;-chan1:\n        fmt.Println(\"Response from service 1\", res, time.Since(start))\n    case res := &lt;-chan2:\n        fmt.Println(\"Response from service 2\", res, time.Since(start))\n    default:\n        fmt.Println(\"No response received\", time.Since(start))\n    }\n\n    fmt.Println(\"main() stopped\", time.Since(start))\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fplay.golang.org\u002Fp\u002FeD0NHxHm9hN\" rel=\"nofollow\"\u003EПример в play.golang.org\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПо итогу мы получим следующий результат:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003Emain() started 0s\nservice1() started 0s\nservice2() started 0s\nResponse from service 1 Hello from service 1 3.0001805s\nmain() stopped 3.0001805s\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИли такой, в некоторых случаях:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003Emain() started 0s\nservice1() started 0s\nservice2() started 0s\nResponse from service 2 Hello from service 2 3.0000957s\nmain() stopped 3.0000957s\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"deadlock\"\u003EDeadlock\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДля того, чтобы избежать \u003Ccode\u003Edeadlock\u003C\u002Fcode\u003E, можно использовать \u003Ccode\u003Edefault\u003C\u002Fcode\u003E, чтобы операции с каналами стали неблокируемыми, планировщик Go не будет планировать горутины для отправки данных в канал, даже если данные не доступны на данный момент.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"go\"\u003Epackage main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nvar start time.Time\n\nfunc init() {\n    start = time.Now()\n}\n\nfunc main() {\n    fmt.Println(\"main() started\", time.Since(start))\n\n    chan1 := make(chan string)\n    chan2 := make(chan string)\n\n    select {\n    case res := &lt;-chan1:\n        fmt.Println(\"Response from chan1\", res, time.Since(start))\n    case res := &lt;-chan2:\n        fmt.Println(\"Response from chan2\", res, time.Since(start))\n    default:\n        fmt.Println(\"No goroutines available to send data\", time.Since(start))\n    }\n\n    fmt.Println(\"main() stopped\", time.Since(start))\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fplay.golang.org\u002Fp\u002FS3Wxuqb8lMF\" rel=\"nofollow\"\u003EПример в play.golang.org\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВывод программы:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003Emain() started 0s\nNo goroutines available to send data 0s\nmain() stopped 0s\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EАналогично получению данных, операция отправки данных будет работать также в случае использования оператора \u003Ccode\u003Edefault\u003C\u002Fcode\u003E, если присутствуют другие горутины, готовые принять отправленные данные (в режиме ожидания).\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3 id=\"nil-kanaly\"\u003Enil каналы\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКак мы уже знаем, нулевое значение в случае канала — это \u003Ccode\u003Enil\u003C\u002Fcode\u003E, из-за этого мы не может выполнять операции отправки или приема данных. При попытке отправить или принять данные через этот канал в блоке \u003Ccode\u003Eselect\u003C\u002Fcode\u003E, мы получим ошибку.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"go\"\u003Epackage main\n\nimport \"fmt\"\n\nfunc service(c chan string) {\n    c &lt;- \"response\"\n}\n\nfunc main() {\n    fmt.Println(\"main() started\")\n\n    var chan1 chan string\n\n    go service(chan1)\n\n    select {\n    case res := &lt;-chan1:\n        fmt.Println(\"Response from chan1\", res)\n    }\n\n    fmt.Println(\"main() stopped\")\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fplay.golang.org\u002Fp\u002FuhraFubcF4S\" rel=\"nofollow\"\u003EПример в play.golang.org\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВывод программы:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003Emain() started\nfatal error: all goroutines are asleep - deadlock!\n\ngoroutine 1 [select (no cases)]:\nmain.main()\n    program.go:17 +0xc0\n\ngoroutine 6 [chan send (nil chan)]:\nmain.service(0x0, 0x1)\n    program.go:6 +0x40\ncreated by main.main\n    program.go:14 +0xa0\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИз полученного результата мы можем заметить, что \u003Ccode\u003Eselect (no cases)\u003C\u002Fcode\u003E означает, что \u003Ccode\u003Eselect\u003C\u002Fcode\u003E оператор пустой, потому что конструкции \u003Ccode\u003Ecase\u003C\u002Fcode\u003E с нулевым каналом игнорируются. Но так как пустой \u003Ccode\u003Eselect{}\u003C\u002Fcode\u003E блокирует \u003Ccode\u003Emain\u003C\u002Fcode\u003E горутину, активируется горутина \u003Ccode\u003Eservice\u003C\u002Fcode\u003E, которая попытается записать данные в \u003Ccode\u003Enil\u003C\u002Fcode\u003E канал, что впоследствии приведет к аварийному завершению программы со следующей ошибкой: \u003Ccode\u003Echan send (nil chan)\u003C\u002Fcode\u003E. Для того, чтобы этого избежать, можно использовать оператор \u003Ccode\u003Edefault\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"go\"\u003Epackage main\n\nimport \"fmt\"\n\nfunc service(c chan string) {\n    c &lt;- \"response\"\n}\n\nfunc main() {\n    fmt.Println(\"main() started\")\n\n    var chan1 chan string\n\n    go service(chan1)\n\n    select {\n    case res := &lt;-chan1:\n        fmt.Println(\"Response from chan1\", res)\n    default:\n        fmt.Println(\"No response\")\n    }\n\n    fmt.Println(\"main() stopped\")\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fplay.golang.org\u002Fp\u002FupLsz52_CrE\" rel=\"nofollow\"\u003EПример в play.golang.org\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВывод программы:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003Emain() started\nNo response\nmain() stopped\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ приведенной программе блоки \u003Ccode\u003Ecase\u003C\u002Fcode\u003E игнорируются, так как блок \u003Ccode\u003Edefault\u003C\u002Fcode\u003E исполняется первым. Поэтому планировщик не запускает горутину \u003Ccode\u003Eservice\u003C\u002Fcode\u003E. Такие программы, естественно, писать не стоит, необходимо всегда проверять, что канал не \u003Ccode\u003Enil\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3 id=\"dobavlyaem-timeout\"\u003EДобавляем timeout\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EРанее написанная программа не особенно полезна из-за того, что блок \u003Ccode\u003Edefault\u003C\u002Fcode\u003E выполнится раньше. Но иногда необходимо, чтобы определенный сервис ответил за определенное время, если он не отвечает, тогда должен выполниться блок \u003Ccode\u003Edefault\u003C\u002Fcode\u003E. Этого можно добиться, используя \u003Ccode\u003Ecase\u003C\u002Fcode\u003E с канальными операциями, которые будут разблокированы после заданного времени. Такая канальная операция предоставляется функцией \u003Ccode\u003EAfter\u003C\u002Fcode\u003E из пакета (package) \u003Ccode\u003Etime\u003C\u002Fcode\u003E. Давайте рассмотрим следующий пример:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"go\"\u003Epackage main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nvar start time.Time\n\nfunc init() {\n    start = time.Now()\n}\n\nfunc service1(c chan string) {\n    time.Sleep(3 * time.Second)\n    c &lt;- \"Hello from service 1\"\n}\n\nfunc service2(c chan string) {\n    time.Sleep(5 * time.Second)\n    c &lt;- \"Hello from service 2\"\n}\n\nfunc main() {\n    fmt.Println(\"main() started\", time.Since(start))\n\n    chan1 := make(chan string)\n    chan2 := make(chan string)\n\n    go service1(chan1)\n    go service2(chan2)\n\n    select {\n    case res := &lt;-chan1:\n        fmt.Println(\"Response from service 1\", res, time.Since(start))\n    case res := &lt;-chan2:\n        fmt.Println(\"Response from service 2\", res, time.Since(start))\n    case &lt;-time.After(2 * time.Second):\n        fmt.Println(\"No response received\", time.Since(start))\n    }\n\n    fmt.Println(\"main() stopped\", time.Since(start))\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fplay.golang.org\u002Fp\u002Fmda2t2IQK__X\" rel=\"nofollow\"\u003EПример в play.golang.org\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДанная программа выдаст следующий результат через 2 секунды:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003Emain() started 0s\nNo response received 2s\nmain() stopped 2s\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ этой программе, благодаря конструкции \u003Ccode\u003E&lt;-time.After(2 * time.Second)\u003C\u002Fcode\u003E горутина \u003Ccode\u003Emain\u003C\u002Fcode\u003E будет разблокирована через 2 секунды. \u003Ccode\u003Etime.After\u003C\u002Fcode\u003E создаёт канал, по которому посылаются метки времени с заданным интервалом. Так как данные из каналов \u003Ccode\u003Echan1\u003C\u002Fcode\u003E и \u003Ccode\u003Echan2\u003C\u002Fcode\u003E не были получены, выполняется 3-й блок, после чего программа успешно завершается.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЭто может быть полезно в случае, когда вы не хотите ждать ответа от сервера продолжительное время. Если изменить \u003Ccode\u003Etime.After(2 * time.Second)\u003C\u002Fcode\u003E на \u003Ccode\u003Etime.After(10 * time.Second)\u003C\u002Fcode\u003E мы получим результат из \u003Ccode\u003Eservice1\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3 id=\"pustoy-select\"\u003EПустой select\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПодобно пустому \u003Ccode\u003Efor{}\u003C\u002Fcode\u003E, пустой \u003Ccode\u003Eselect{}\u003C\u002Fcode\u003E так же является валидным, но есть подвох. Как мы уже знаем \u003Ccode\u003Eselect\u003C\u002Fcode\u003E блокируется до тех пор, пока один из блоков \u003Ccode\u003Ecase\u003C\u002Fcode\u003E не будет выполнен, но так как в пустом \u003Ccode\u003Eselect\u003C\u002Fcode\u003E отсутствуют блоки \u003Ccode\u003Ecase\u003C\u002Fcode\u003E, горутина не будет разблокирована, и как результат, мы получим \u003Ccode\u003Edeadlock\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"go\"\u003Epackage main\n\nimport \"fmt\"\n\nfunc service() {\n    fmt.Println(\"Hello from service!\")\n}\n\nfunc main() {\n    fmt.Println(\"main() started\")\n\n    go service()\n\n    select {}\n\n    fmt.Println(\"main() stopped\")\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fplay.golang.org\u002Fp\u002F-pBd-BLMFOu\" rel=\"nofollow\"\u003EПример в play.golang.org\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ результате мы получим следующий вывод:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003Emain() started\nHello from service!\nfatal error: all goroutines are asleep - deadlock!\ngoroutine 1 [select (no cases)]:\nmain.main()\n        program.go:16 +0xba\nexit status 2\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3 id=\"waitgroup\"\u003EWaitGroup\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТеперь давайте представим состояние, когда вам нужно узнать, что все горутины были выполнены (Примечание переводчика: например, операция сложения запущенная в нескольких горутинах). Такая задача является прямо противоположной тому, что мы делали с \u003Ccode\u003Eselect\u003C\u002Fcode\u003E. Здесь мы дожидаемся полного завершения всех горутин.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНа помощь нам приходит WaitGroup. Это структура со счетчиком, которая отслеживает сколько горутин вами было создано, и сколько из них было завершено (Примечание переводчика: сама она это делать не умеет, но есть методы, которые позволят вам добиться этого, так же подобного можно добиться с использованием каналов, но это считается устаревшим подходом и, как вы уже могли заметить, имеет ряд недостатков). Достижение счетчиком нуля будет означать, что все горутины были выполнены.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДавайте разберем следующий пример:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"go\"\u003Epackage main\n\nimport (\n    \"fmt\"\n    \"sync\"\n    \"time\"\n)\n\nfunc service(wg *sync.WaitGroup, instance int) {\n    time.Sleep(2 * time.Second)\n    fmt.Println(\"Service called on instance\", instance)\n    wg.Done() \u002F\u002F decrement counter\n}\n\nfunc main() {\n    fmt.Println(\"main() started\")\n    var wg sync.WaitGroup \u002F\u002F create waitgroup (empty struct)\n\n    for i := 1; i &lt;= 3; i++ {\n        wg.Add(1) \u002F\u002F increment counter\n        go service(&amp;wg, i)\n    }\n\n    wg.Wait() \u002F\u002F blocks here\n    fmt.Println(\"main() stopped\")\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fplay.golang.org\u002Fp\u002F8qrAD9ceOfJ\" rel=\"nofollow\"\u003EПример в play.golang.org\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ этой программе мы создали пустой WaitGroup, внутри себя эта структура содержит приватные поля \u003Ccode\u003EnoCopy\u003C\u002Fcode\u003E и \u003Ccode\u003Estate1\u003C\u002Fcode\u003E (\u003Ca href=\"https:\u002F\u002Fgolang.org\u002Fsrc\u002Fsync\u002Fwaitgroup.go?s=574:929#L10\" rel=\"nofollow\"\u003Ehttps:\u002F\u002Fgolang.org\u002Fsrc\u002Fsync\u002Fwaitgroup.go?s=574:929#L10\u003C\u002Fa\u003E). Структура имеет три метода: \u003Ccode\u003EAdd\u003C\u002Fcode\u003E, \u003Ccode\u003EWait\u003C\u002Fcode\u003E и \u003Ccode\u003EDone\u003C\u002Fcode\u003E. Давайте их рассмотрим.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EМетод \u003Ccode\u003EAdd\u003C\u002Fcode\u003E принимает \u003Ccode\u003Eint\u003C\u002Fcode\u003E аргумент, который является \u003Ccode\u003Edelta\u003C\u002Fcode\u003E (дельтой) для счетчика \u003Ccode\u003EWaitGroup\u003C\u002Fcode\u003E. Где счетчика — это число со значением, по умолчанию равным 0. Он хранит число запущенных горутин. Когда \u003Ccode\u003EWaitGroup\u003C\u002Fcode\u003E создана, значение счетчика будет равно 0, и мы можем увеличивать его, передавая \u003Ccode\u003Edelta\u003C\u002Fcode\u003E как параметр метода \u003Ccode\u003EAdd\u003C\u002Fcode\u003E. Счетчика не понимает автоматически, когда была запущена программа, поэтому нам нужно вручную увеличивать его, используя функцию \u003Ccode\u003EAdd\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EМетод \u003Ccode\u003EWait\u003C\u002Fcode\u003E используется для блокировки текущей горутины, когда мы его вызываем. Как только счетчик достигнет 0, горутина будет разблокирована. Поэтому нам необходимо как-то уменьшать значение счетчика.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EМетод \u003Ccode\u003EDone\u003C\u002Fcode\u003E уменьшает значение счетчика. Он не принимает никаких параметров. (Примечание переводчика: если посмотреть исходники пакета \u003Ccode\u003Esync\u003C\u002Fcode\u003E, то можно увидеть, что внутри себя он просто вызывает \u003Ca href=\"https:\u002F\u002Fgolang.org\u002Fsrc\u002Fsync\u002Fwaitgroup.go?s=574:929#L98\" rel=\"nofollow\"\u003EAdd(-1)\u003C\u002Fa\u003E).\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИ так, после создания \u003Ccode\u003Ewg\u003C\u002Fcode\u003E, мы запускаем итерацию в цикле \u003Ccode\u003Efor\u003C\u002Fcode\u003E от 1 до 3х включительно. На каждой итерации мы запускаем горутину и инкрементируем счетчик на 1. Таким образом у нас будет 3 запущенных горутины, которые необходимо выполнить и \u003Ccode\u003EWaitGroup\u003C\u002Fcode\u003E со значением счетчика равным 3. Заметьте, что мы передали указатель на \u003Ccode\u003Ewg\u003C\u002Fcode\u003E в горутину. Это необходимо, чтобы вызвать \u003Ccode\u003EDone\u003C\u002Fcode\u003E в горутине после завершения работы, что в свою очередь уменьшит значение счетчика.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПосле выполнения цикла \u003Ccode\u003Efor\u003C\u002Fcode\u003E, мы запускаем \u003Ccode\u003Ewg.Wait()\u003C\u002Fcode\u003E, чтобы передать управление другим горутинам, и, как следствие, это заблокирует наш \u003Ccode\u003Emain\u003C\u002Fcode\u003E до тех пор, пока все горутины не будут завершены, и значение счетчика не будет равно 0. После чего \u003Ccode\u003Emain\u003C\u002Fcode\u003E будет разблокирована, и программа будет успешно завершена.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТаким образом мы получим следующий вывод:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003Emain() started\nService called on instance 1\nService called on instance 3\nService called on instance 2\nmain() stopped\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EРезультат выше может отличаться, из-за порядка выполнения горутин.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3 id=\"pul-vorkerov\"\u003EПул воркеров\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКак следует из названия, пул воркеров — это набор горутин, работающих одновременно для определенной задачи. В примере \u003Ccode\u003EWaitGroup\u003C\u002Fcode\u003E мы увидели набор горутин, работающих одновременно, но у них не было определенной задачи. Как только вы добавляете каналы в горутины, у них появляется какая-то работа, и они становятся пулом воркеров.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"go\"\u003Epackage main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\n\u002F\u002F worker than make squares\nfunc sqrWorker(tasks &lt;-chan int, results chan&lt;- int, id int) {\n    for num := range tasks {\n        time.Sleep(time.Millisecond) \u002F\u002F simulating blocking task\n        fmt.Printf(\"[worker %v] Sending result by worker %v\\n\", id, id)\n        results &lt;- num * num\n    }\n}\n\nfunc main() {\n    fmt.Println(\"[main] main() started\")\n\n    tasks := make(chan int, 10)\n    results := make(chan int, 10)\n\n    \u002F\u002F launching 3 worker goroutines\n    for i := 0; i &lt; 3; i++ {\n        go sqrWorker(tasks, results, i)\n    }\n\n    \u002F\u002F passing 5 tasks\n    for i := 0; i &lt; 5; i++ {\n        tasks &lt;- i * 2 \u002F\u002F non-blocking as buffer capacity is 10\n    }\n\n    fmt.Println(\"[main] Wrote 5 tasks\")\n\n    \u002F\u002F closing tasks\n    close(tasks)\n\n    \u002F\u002F receving results from all workers\n    for i := 0; i &lt; 5; i++ {\n        result := &lt;-results \u002F\u002F blocking because buffer is empty\n        fmt.Println(\"[main] Result\", i, \":\", result)\n    }\n\n    fmt.Println(\"[main] main() stopped\")\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fplay.golang.org\u002Fp\u002FIYiMV1I4lCj\" rel=\"nofollow\"\u003EПример в play.golang.org\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВывод программы:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003E[main] main() started\n[main] Wrote 5 tasks\n[worker 0] Sending result by worker 0\n[worker 2] Sending result by worker 2\n[worker 1] Sending result by worker 1\n[main] Result 0 : 4\n[main] Result 1 : 0\n[main] Result 2 : 16\n[worker 2] Sending result by worker 2\n[main] Result 3 : 64\n[worker 0] Sending result by worker 0\n[main] Result 4 : 36\n[main] main() stopped\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИтак, давайте разберемся с тем, что тут происходит:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Col\u003E\r\n\u003Cli\u003EФункция \u003Ccode\u003EsqrWorker\u003C\u002Fcode\u003E принимает канал \u003Ccode\u003Etasks\u003C\u002Fcode\u003E, канал \u003Ccode\u003Eresults\u003C\u002Fcode\u003E, а так же \u003Ccode\u003Eid\u003C\u002Fcode\u003E. Задача этой горутины — отправлять квадрат числа, полученного из канала \u003Ccode\u003Etasks\u003C\u002Fcode\u003E, в канал \u003Ccode\u003Eresults\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\r\n\u003Cli\u003EВ функции \u003Ccode\u003Emain\u003C\u002Fcode\u003E, мы создали каналы \u003Ccode\u003Etasks\u003C\u002Fcode\u003E и \u003Ccode\u003Eresult\u003C\u002Fcode\u003E с размером буфера, равной 10. Следовательно, любая операция отправки будет неблокируемой, пока буфер не заполнится. Поэтому канал с буфером большого размера — это неплохая идея.\u003C\u002Fli\u003E\r\n\u003Cli\u003EЗатем мы порождаем несколько экземпляров \u003Ccode\u003EsqrWorker\u003C\u002Fcode\u003E в виде горутин с двумя вышеописанными каналами и параметром \u003Ccode\u003Eid\u003C\u002Fcode\u003E, чтобы позже получить информацию о том, какой воркер выполняет задачу.\u003C\u002Fli\u003E\r\n\u003Cli\u003EДалее мы передали 5 значений каналу \u003Ccode\u003Etasks\u003C\u002Fcode\u003E, операция будет неблокируемой, так как размер буфера не превышен.\u003C\u002Fli\u003E\r\n\u003Cli\u003EТак как мы закончили с каналом \u003Ccode\u003Etasks\u003C\u002Fcode\u003E, закрываем его. В этом нет необходимости, но это сэкономит много времени в будущем, если появятся ошибки.\u003C\u002Fli\u003E\r\n\u003Cli\u003EИспользуя цикл \u003Ccode\u003Efor\u003C\u002Fcode\u003E с 5ю итерациями, мы извлекаем результат из канала \u003Ccode\u003Eresults\u003C\u002Fcode\u003E. Так как операция чтения на пустом буфере является блокируемой, планировщик запустит горутину из пула воркеров. До тех пор, пока горутина не вернет результат, \u003Ccode\u003Emain\u003C\u002Fcode\u003E будет заблокирован.\u003C\u002Fli\u003E\r\n\u003Cli\u003EПоскольку мы симулируем операцию блокировки в горутине, это приведет к вызову планировщиком другой доступной горутины для запуска. Когда горутина запустится, она запишет результат в канал \u003Ccode\u003Eresults\u003C\u002Fcode\u003E, а так как операция записи в канал с буфером является неблокируемым до тех пор, пока буфер не заполнен, блокировки при записи не произойдет. Таким образом как только одна из горутин завершится, запустятся другие горутины и считают данные из канала \u003Ccode\u003Etasks\u003C\u002Fcode\u003E. После того, как все горутины считают данные из \u003Ccode\u003Etasks\u003C\u002Fcode\u003E, цикл \u003Ccode\u003Efor\u003C\u002Fcode\u003E завершится, а канал \u003Ccode\u003Etasks\u003C\u002Fcode\u003E будет пустым. Так же не произойдет ошибка \u003Ccode\u003Edeadlock\u003C\u002Fcode\u003E, так как канал \u003Ccode\u003Etasks\u003C\u002Fcode\u003E был закрыт.\u003C\u002Fli\u003E\r\n\u003Cli\u003EИногда все воркеры могут находиться в режиме ожидания, поэтому \u003Ccode\u003Emain\u003C\u002Fcode\u003E программа будет работать до тех пор, пока канал \u003Ccode\u003Eresults\u003C\u002Fcode\u003E не будет пуст.\u003C\u002Fli\u003E\r\n\u003Cli\u003EПосле того, как все воркеры отработают, \u003Ccode\u003Emain\u003C\u002Fcode\u003E восстановит контроль, выведет оставшиеся результаты из канала \u003Ccode\u003Eresults\u003C\u002Fcode\u003E, и продолжит выполнение.\u003C\u002Fli\u003E\r\n\u003C\u002Fol\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПриведенный пример достаточно большой, но прекрасно объясняет, как несколько горутин могут извлекать данные из канала и выполнять свою работу. Горутины весьма эффективны, когда они могут блокироваться. Если убрать вызов \u003Ccode\u003Etime.Sleep()\u003C\u002Fcode\u003E, то только одна горутина будет выполняться, так как другие горутины не будут запланированы, до тех пор пока цикл не закончится и горутина не завершится.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003EВы можете получить другой результат в приведенном примере, в зависимости от скорости работы вашей системы.\u003C\u002Fblockquote\u003E\u003Cp\u003EДавайте воспользуемся концепцией \u003Ccode\u003EWaitGroup\u003C\u002Fcode\u003E для синхронизации горутин. Используя предыдущий пример с \u003Ccode\u003EWaitGroup\u003C\u002Fcode\u003E, мы можем получить те же результаты, но более элегантно.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"go\"\u003Epackage main\n\nimport (\n    \"fmt\"\n    \"sync\"\n    \"time\"\n)\n\n\u002F\u002F worker than make squares\nfunc sqrWorker(wg *sync.WaitGroup, tasks &lt;-chan int, results chan&lt;- int, instance int) {\n    for num := range tasks {\n        time.Sleep(time.Millisecond)\n        fmt.Printf(\"[worker %v] Sending result by worker %v\\n\", instance, instance)\n        results &lt;- num * num\n    }\n\n    \u002F\u002F done with worker\n    wg.Done()\n}\n\nfunc main() {\n    fmt.Println(\"[main] main() started\")\n\n    var wg sync.WaitGroup\n\n    tasks := make(chan int, 10)\n    results := make(chan int, 10)\n\n    \u002F\u002F launching 3 worker goroutines\n    for i := 0; i &lt; 3; i++ {\n        wg.Add(1)\n        go sqrWorker(&amp;wg, tasks, results, i)\n    }\n\n    \u002F\u002F passing 5 tasks\n    for i := 0; i &lt; 5; i++ {\n        tasks &lt;- i * 2 \u002F\u002F non-blocking as buffer capacity is 10\n    }\n\n    fmt.Println(\"[main] Wrote 5 tasks\")\n\n    \u002F\u002F closing tasks\n    close(tasks)\n\n    \u002F\u002F wait until all workers done their job\n    wg.Wait()\n\n    \u002F\u002F receving results from all workers\n    for i := 0; i &lt; 5; i++ {\n        result := &lt;-results \u002F\u002F non-blocking because buffer is non-empty\n        fmt.Println(\"[main] Result\", i, \":\", result)\n    }\n\n    fmt.Println(\"[main] main() stopped\")\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fplay.golang.org\u002Fp\u002F0rRfchn7sL1\" rel=\"nofollow\"\u003EПример в play.golang.org\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EРезультат работы программы:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003E[main] main() started\n[main] Wrote 5 tasks\n[worker 0] Sending result by worker 0\n[worker 2] Sending result by worker 2\n[worker 1] Sending result by worker 1\n[worker 2] Sending result by worker 2\n[worker 0] Sending result by worker 0\n[main] Result 0 : 4\n[main] Result 1 : 0\n[main] Result 2 : 16\n[main] Result 3 : 64\n[main] Result 4 : 36\n[main] main() stopped\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ приведенном результате мы получили немного другой, более аккуратный вывод, потому что операция чтения из канала \u003Ccode\u003Eresults\u003C\u002Fcode\u003E в \u003Ccode\u003Emain\u003C\u002Fcode\u003E не блокируется, так как канал \u003Ccode\u003Eresults\u003C\u002Fcode\u003E уже содержит данные из-за вызванного ранее \u003Ccode\u003Ewg.Wait()\u003C\u002Fcode\u003E. Используя \u003Ccode\u003EWaitGroup\u003C\u002Fcode\u003E, мы можем предотвратить много (ненужных) переключений контекста (планирование горутин и их запуск), в данном случае 7 против 9 в предыдущем примере. Но при этом вам приходится ожидать завершения всех горутин.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3 id=\"myuteks\"\u003EМьютекс\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EМьютекс — это один из самых простых концепций в Go. Но прежде чем разобраться в нем, давайте для начала разберемся в понятии \u003Ccode\u003Erace condition\u003C\u002Fcode\u003E(\u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002F%D0%A1%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B5_%D0%B3%D0%BE%D0%BD%D0%BA%D0%B8\" rel=\"nofollow\"\u003Eсостоянии гонки\u003C\u002Fa\u003E). Горутины имеют независимый стек, следовательно нет необходимости в обмене данными между ними. Но, иногда, необходимо использовать общие данные между несколькими горутинами. В этом случае несколько горутин пытаются взаимодействовать с данными в общей области памяти, что иногда приводит к непредсказуемому результату. Рассмотрим простой пример:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"go\"\u003Epackage main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\nvar i int \u002F\u002F i == 0\n\n\u002F\u002F goroutine increment global variable i\nfunc worker(wg *sync.WaitGroup) {\n    i = i + 1\n    wg.Done()\n}\n\nfunc main() {\n    var wg sync.WaitGroup\n\n    for i := 0; i &lt; 1000; i++ {\n        wg.Add(1)\n        go worker(&amp;wg)\n    }\n\n    \u002F\u002F wait until all 1000 goroutines are done\n    wg.Wait()\n\n    \u002F\u002F value of i should be 1000\n    fmt.Println(\"value of i after 1000 operations is\", i)\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fplay.golang.org\u002Fp\u002FMQNepChxiEa\" rel=\"nofollow\"\u003EПример в play.golang.org\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ приведенной программе мы порождаем 1000 горутин, которые увеличивают значение глобальной переменной \u003Ccode\u003Ei\u003C\u002Fcode\u003E, равной изначально 0. Мы написали программу с использованием \u003Ccode\u003EWaitGroup\u003C\u002Fcode\u003E, поскольку мы хотим, чтобы все 1000 горутин увеличивали значение \u003Ccode\u003Ei\u003C\u002Fcode\u003E последовательно, и, в результате, итоговое значение было равно 1000. Когда \u003Ccode\u003Emain\u003C\u002Fcode\u003E восстанавливается после вызова \u003Ccode\u003Ewg.Wait()\u003C\u002Fcode\u003E, мы выводим значение \u003Ccode\u003Ei\u003C\u002Fcode\u003E. Давайте посмотрим на конечный результат:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003Evalue of i after 1000 operations is 937\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЧто? Почему мы получили значение меньше 1000? Возможно часть горутин не отработала. Но, в действительности, произошло \u003Ccode\u003Erace condition\u003C\u002Fcode\u003E. Посмотрим, как это могло случиться.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВычисление \u003Ccode\u003Ei = i + 1\u003C\u002Fcode\u003E состоит из трех шагов:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Col\u003E\r\n\u003Cli\u003EПолучить значение \u003Ccode\u003Ei\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003EУвеличить на 1\u003C\u002Fli\u003E\r\n\u003Cli\u003EОбновить значение \u003Ccode\u003Ei\u003C\u002Fcode\u003E с новым значением\u003C\u002Fli\u003E\r\n\u003C\u002Fol\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДавайте представим следующий сценарий, в котором между этими шагами были запланированы разные горутины. К примеру, рассмотрим 2 горутины из пула 1000 горутин, а именно. G1 и G2.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EG1 запускается, когда \u003Ccode\u003Ei\u003C\u002Fcode\u003E равна 0, после второго шага \u003Ccode\u003Ei\u003C\u002Fcode\u003E стала равной 1. Но перед тем, как G1 изменит значение \u003Ccode\u003Ei\u003C\u002Fcode\u003E на 1 в шаге 3, новая горутина G2 уже была запланирована, и эта горутина выполнит те же шаги. В случае G2, значение \u003Ccode\u003Ei\u003C\u002Fcode\u003E все еще 0, поэтому на третьем шаге значение \u003Ccode\u003Ei\u003C\u002Fcode\u003E будет равно 1, в это время G1 собирается закончить третий шаг и изменить значение \u003Ccode\u003Ei\u003C\u002Fcode\u003E на 1. В идеальном мире, где горутины планируются после выполнения всех 3-х шагов, успешное выполнение 2х горутин привело бы к значению \u003Ccode\u003Ei\u003C\u002Fcode\u003E равному 2, но это не так. Поэтому, мы можем предположить, почему наша программа не выдает значение \u003Ccode\u003Ei\u003C\u002Fcode\u003E равным 1000.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКак мы знаем, горутины планируются совместно и до тех пор, пока горутина не заблокируется по одному из условий, другая горутина не будет запланирована. Но операция \u003Ccode\u003Ei = i + 1\u003C\u002Fcode\u003E не является блокируемой, тогда почему планировщик Go планирует другие горутины?\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВы можете посмотреть ответ на \u003Ca href=\"https:\u002F\u002Fstackoverflow.com\u002Fquestions\u002F37469995\u002Fgoroutines-are-cooperatively-scheduled-does-that-mean-that-goroutines-that-don\" rel=\"nofollow\"\u003Estackoverflow\u003C\u002Fa\u003E. В любом случае не следует полагаться на алгоритм планирования Go и реализовывать собственную логику для синхронизации различных программ.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EОдин из способов удостовериться, что горутина выполнит все 3 вышеуказанных шага за раз, это использовать мьютекс. \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002F%D0%9C%D1%8C%D1%8E%D1%82%D0%B5%D0%BA%D1%81\" rel=\"nofollow\"\u003EМьютекс\u003C\u002Fa\u003E — это концепция в программировании, где только один поток может выполнять несколько операций одновременно. Это делается с помощью подпрограммы, получающей блокировку для выполнения любых манипуляции со значением, которое она должна изменить, а затем снимает блокировку после. Когда значение заблокировано, никакая другая подпрограмма не может читать или записывать его.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ Go мьютексы — это структура данных, которую предоставляет пакет \u003Ccode\u003Esync\u003C\u002Fcode\u003E. В Go перед выполнением любой операции со значением, которое может вызвать \u003Ccode\u003Erace condition\u003C\u002Fcode\u003E, мы получаем эксклюзивную блокировку, используя метод \u003Ccode\u003Emutex.Lock()\u003C\u002Fcode\u003E. Как только мы выполнили операцию \u003Ccode\u003Ei = i + 1\u003C\u002Fcode\u003E в ранее написанной программе, мы снимаем блокировки, используя метод \u003Ccode\u003Emutext.Unlock()\u003C\u002Fcode\u003E. Когда любая другая горутина попытается прочитать или записать значение \u003Ccode\u003Ei\u003C\u002Fcode\u003E при наличии блокировки, эта программа будет блокироваться до тех пор, пока мьютекс не будет разблокирован. И горутина сможет безопасно читать и писать данные в переменную \u003Ccode\u003Ei\u003C\u002Fcode\u003E. Запомните, что любые переменные, находящиеся между \u003Ccode\u003ELock\u003C\u002Fcode\u003E и \u003Ccode\u003EUnlock\u003C\u002Fcode\u003E, будут недоступны для других горутин до тех пор, пока не выполнится операция снятия блокировки.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДавайте изменим предыдущий пример, используя мьютекс.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"go\"\u003Epackage main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\nvar i int \u002F\u002F i == 0\n\n\u002F\u002F goroutine increment global variable i\nfunc worker(wg *sync.WaitGroup, m *sync.Mutex) {\n    m.Lock() \u002F\u002F acquire lock\n    i = i + 1\n    m.Unlock() \u002F\u002F release lock\n    wg.Done()\n}\n\nfunc main() {\n    var wg sync.WaitGroup\n    var m sync.Mutex\n\n    for i := 0; i &lt; 1000; i++ {\n        wg.Add(1)\n        go worker(&amp;wg, &amp;m)\n    }\n\n    \u002F\u002F wait until all 1000 goroutines are done\n    wg.Wait()\n\n    \u002F\u002F value of i should be 1000\n    fmt.Println(\"value of i after 1000 operations is\", i)\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ данной программе мы создали мьютекс и передали его указатель во все горутины, прежде чем выполнить операцию с переменной \u003Ccode\u003Ei\u003C\u002Fcode\u003E, мы получили эксклюзивную блокировку, используя \u003Ccode\u003Em.Lock()\u003C\u002Fcode\u003E, а после операций с переменной \u003Ccode\u003Ei\u003C\u002Fcode\u003E мы сняли блокировку, используя \u003Ccode\u003Em.Unlock()\u003C\u002Fcode\u003E. Таким образом мы получим следующий результат:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003Evalue of i after 1000 operations is 1000\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИз приведенного результата видно, что мьютекс помог нам разрешить \u003Ccode\u003Erace condition\u003C\u002Fcode\u003E. Но старайтесь избегать использования общих ресурсов между горутинами.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003EВы можете проверить программу на \u003Ccode\u003Erace condition\u003C\u002Fcode\u003E в Go, используя флаг \u003Ccode\u003Erace\u003C\u002Fcode\u003E, при запуске программы. \u003Ccode\u003Ego run -race program.go\u003C\u002Fcode\u003E. Более подробно об этом можно прочитать \u003Ca href=\"https:\u002F\u002Fblog.golang.org\u002Frace-detector\" rel=\"nofollow\"\u003Eздесь\u003C\u002Fa\u003E.\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"patterny-konkurentnogo-programmirovaniya\"\u003EПаттерны конкурентного программирования\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EСуществует множество способов, с помощью которых параллелизм делает нашу повседневную жизнь проще. Ниже приведены несколько концепций и методологий, с помощью которых мы можем сделать программы быстрее и надежнее.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3 id=\"generator\"\u003EГенератор\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИспользуя каналы, мы можем достаточно просто реализовать генератор. Так как вычисления в генераторе могут являться вычислительно дорогими, то мы могли бы сделать генерацию данных конкурентно. Таким образом, программе не нужно ждать, пока все данные будут сгенерированы. Например, генерация ряда Фибоначчи.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"go\"\u003Epackage main\n\nimport \"fmt\"\n\n\u002F\u002F fib returns a channel which transports fibonacci numbers\nfunc fib(length int) &lt;-chan int {\n    \u002F\u002F make buffered channel\n    c := make(chan int, length)\n\n    \u002F\u002F run generation concurrently\n    go func() {\n        for i, j := 0, 1; i &lt; length; i, j = i+j, i {\n            c &lt;- i\n        }\n        close(c)\n    }()\n\n    \u002F\u002F return channel\n    return c\n}\n\nfunc main() {\n    \u002F\u002F read 10 fibonacci numbers from channel returned by `fib` function\n    for fn := range fib(10) {\n        fmt.Println(\"Current fibonacci number is\", fn)\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003ECurrent fibonacci number is 0\nCurrent fibonacci number is 1\nCurrent fibonacci number is 1\nCurrent fibonacci number is 2\nCurrent fibonacci number is 3\nCurrent fibonacci number is 5\nCurrent fibonacci number is 8\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИспользуя функцию fib, мы получаем канал, который мы можем использовать в цикле. Находясь внутри функции fib, мы создаем и возвращаем канал только для приема. Возвращаемый канал преобразуется из двунаправленного канала в однонаправленный канал для приема. Используя анонимную горутину, мы помещаем числа Фибоначчи в этот канал. Как только мы закончили с циклом \u003Ccode\u003Efor\u003C\u002Fcode\u003E, мы закрываем канал внутри анонимной горутины. В \u003Ccode\u003Emain\u003C\u002Fcode\u003E, используя \u003Ccode\u003Erange\u003C\u002Fcode\u003E, мы итерируем данные канала, полученные после вызова функции \u003Ccode\u003Efib\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3 id=\"fan-in-i-fan-out\"\u003EFan-in и Fan-out\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EFan-in — это стратегия мультиплексирования, при которой входы нескольких каналов объединяются в один выходной канал. Fan-out — это обратная операция, при которой один канал разделяется на несколько каналов.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"go\"\u003E\npackage main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\n\u002F\u002F return channel for input numbers\nfunc getInputChan() &lt;-chan int {\n    \u002F\u002F make return channel\n    input := make(chan int, 100)\n\n    \u002F\u002F sample numbers\n    numbers := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n\n    \u002F\u002F run goroutine\n    go func() {\n        for num := range numbers {\n            input &lt;- num\n        }\n        \u002F\u002F close channel once all numbers are sent to channel\n        close(input)\n    }()\n\n    return input\n}\n\n\u002F\u002F returns a channel which returns square of numbers\nfunc getSquareChan(input &lt;-chan int) &lt;-chan int {\n    \u002F\u002F make return channel\n    output := make(chan int, 100)\n\n    \u002F\u002F run goroutine\n    go func() {\n        \u002F\u002F push squares until input channel closes\n        for num := range input {\n            output &lt;- num * num\n        }\n\n        \u002F\u002F close output channel once for loop finishes\n        close(output)\n    }()\n\n    return output\n}\n\n\u002F\u002F returns a merged channel of `outputsChan` channels\n\u002F\u002F this produce fan-in channel\n\u002F\u002F this is variadic function\nfunc merge(outputsChan ...&lt;-chan int) &lt;-chan int {\n    \u002F\u002F create a WaitGroup\n    var wg sync.WaitGroup\n\n    \u002F\u002F make return channel\n    merged := make(chan int, 100)\n\n    \u002F\u002F increase counter to number of channels `len(outputsChan)`\n    \u002F\u002F as we will spawn number of goroutines equal to number of channels received to merge\n    wg.Add(len(outputsChan))\n\n    \u002F\u002F function that accept a channel (which sends square numbers)\n    \u002F\u002F to push numbers to merged channel\n    output := func(sc &lt;-chan int) {\n        \u002F\u002F run until channel (square numbers sender) closes\n        for sqr := range sc {\n            merged &lt;- sqr\n        }\n        \u002F\u002F once channel (square numbers sender) closes,\n        \u002F\u002F call `Done` on `WaitGroup` to decrement counter\n        wg.Done()\n    }\n\n    \u002F\u002F run above `output` function as groutines, `n` number of times\n    \u002F\u002F where n is equal to number of channels received as argument the function\n    \u002F\u002F here we are using `for range` loop on `outputsChan` hence no need to manually tell `n`\n    for _, optChan := range outputsChan {\n        go output(optChan)\n    }\n\n    \u002F\u002F run goroutine to close merged channel once done\n    go func() {\n        \u002F\u002F wait until WaitGroup finishes\n        wg.Wait()\n        close(merged)\n    }()\n\n    return merged\n}\n\nfunc main() {\n    \u002F\u002F step 1: get input numbers channel\n    \u002F\u002F by calling `getInputChan` function, it runs a goroutine which sends number to returned channel\n    chanInputNums := getInputChan()\n\n    \u002F\u002F step 2: `fan-out` square operations to multiple goroutines\n    \u002F\u002F this can be done by calling `getSquareChan` function multiple times where individual function call returns a channel which sends square of numbers provided by `chanInputNums` channel\n    \u002F\u002F `getSquareChan` function runs goroutines internally where squaring operation is ran concurrently\n    chanOptSqr1 := getSquareChan(chanInputNums)\n    chanOptSqr2 := getSquareChan(chanInputNums)\n\n    \u002F\u002F step 3: fan-in (combine) `chanOptSqr1` and `chanOptSqr2` output to merged channel\n    \u002F\u002F this is achieved by calling `merge` function which takes multiple channels as arguments\n    \u002F\u002F and using `WaitGroup` and multiple goroutines to receive square number, we can send square numbers\n    \u002F\u002F to `merged` channel and close it\n    chanMergedSqr := merge(chanOptSqr1, chanOptSqr2)\n\n    \u002F\u002F step 4: let's sum all the squares from 0 to 9 which should be about `285`\n    \u002F\u002F this is done by using `for range` loop on `chanMergedSqr`\n    sqrSum := 0\n\n    \u002F\u002F run until `chanMergedSqr` or merged channel closes\n    \u002F\u002F that happens in `merge` function when all goroutines pushing to merged channel finishes\n    \u002F\u002F check line no. 86 and 87\n    for num := range chanMergedSqr {\n        sqrSum += num\n    }\n\n    \u002F\u002F step 5: print sum when above `for loop` is done executing which is after `chanMergedSqr` channel closes\n    fmt.Println(\"Sum of squares between 0-9 is\", sqrSum)\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПройдем по шагам.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Col\u003E\r\n\u003Cli\u003EПолучаем канал \u003Ccode\u003EchanInputNums\u003C\u002Fcode\u003E, посредством вызова функции \u003Ccode\u003EgetInputChan\u003C\u002Fcode\u003E. Функция \u003Ccode\u003EgetInputChan\u003C\u002Fcode\u003E создает канал и возвращает его как канал, доступный только для чтения, а также запускает анонимную горутину, которая последовательно помещает в канал числа из массива \u003Ccode\u003Enumbers\u003C\u002Fcode\u003E и закрывает канал.\u003C\u002Fli\u003E\r\n\u003Cli\u003EРазделяем наш канал (fan-out) на два канала(\u003Ccode\u003EchanOptSqr1\u003C\u002Fcode\u003E и \u003Ccode\u003EchanOptSqr2\u003C\u002Fcode\u003E), передавая его два раза функции \u003Ccode\u003EgetSquareChan\u003C\u002Fcode\u003E. Функция \u003Ccode\u003EgetSquareChan\u003C\u002Fcode\u003E создает канал и возвращает его как канал, доступный только для чтения, а также запускает анонимную горутину для вычисления квадрата чисел на основе данных канала, полученного в качестве аргумента функции.\u003C\u002Fli\u003E\r\n\u003Cli\u003EСобираем данные из каналов в один (fan-in), используя функцию \u003Ccode\u003Emerge\u003C\u002Fcode\u003E. В функции \u003Ccode\u003Emerge\u003C\u002Fcode\u003E мы создаем \u003Ccode\u003EWaitGroup\u003C\u002Fcode\u003E, а также новый канал(\u003Ccode\u003Emerged\u003C\u002Fcode\u003E), где мы объединим все данные из списка каналов \u003Ccode\u003EoutputsChan\u003C\u002Fcode\u003E, после, мы увеличиваем счетчик на основании числа полученных каналов, подготавливаем анонимную функцию для чтения данных из канала и группировки данных в наш новый канал \u003Ccode\u003Emerged\u003C\u002Fcode\u003E, а также уменьшим значение счетчика, когда все данные из переданного канала будут считаны. Вызываем нашу анонимную функцию для каждого канала в качестве горутины. А так же создаем и стартуем еще одну анонимную горутину для того, чтобы дождаться выполнения операции объединения всех данных в один канал и после этого закрываем канал в рамках анонимной функции. После чего возвращаем наш новый канал \u003Ccode\u003Emerged\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\r\n\u003Cli\u003EСчитываем данные из канала \u003Ccode\u003EchanMergedSqr\u003C\u002Fcode\u003E используя \u003Ccode\u003Efor\u003C\u002Fcode\u003E и \u003Ccode\u003Erange\u003C\u002Fcode\u003E, и суммируем полученные данные.\u003C\u002Fli\u003E\r\n\u003Cli\u003EВ конце выводим наш результат.\u003C\u002Fli\u003E\r\n\u003C\u002Fol\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВывод программы:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003ESum of squares between 0-9 is 285\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EUPDATE:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДополнительная литература по внутреннему устройству каналов:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Col\u003E\r\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fpost\u002F308070\u002F\"\u003EКак устроены каналы в Go\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fmedium.com\u002F@victor_nerd\u002F%D0%BF%D0%BE%D0%B4-%D0%BA%D0%B0%D0%BF%D0%BE%D1%82%D0%BE%D0%BC-golang-%D0%BA%D0%B0%D0%BA-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D1%8E%D1%82-%D0%BA%D0%B0%D0%BD%D0%B0%D0%BB%D1%8B-%D1%87%D0%B0%D1%81%D1%82%D1%8C-1-e1da9e3e104d\" rel=\"nofollow\"\u003EПод капотом Golang — как работают каналы. Часть 1.\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fmedium.com\u002F@victor_nerd\u002Fgolang-channel-internal-part2-b4e37ad9a118\" rel=\"nofollow\"\u003EСтроение каналов в Golang. Часть 2.\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003C\u002Fol\u003E\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"golang"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F490336\u002Fc3baa6d7e4776d1acd4196a4a9814462\u002F","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F490336\u002Fc3baa6d7e4776d1acd4196a4a9814462\u002F?format=vk","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F490336\\\u002F\"},\"headline\":\"Анатомия каналов в Go\",\"datePublished\":\"2020-02-28T11:28:02+03:00\",\"dateModified\":\"2020-03-03T16:35:41+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"Алексей\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"Привет, Хабр! Представляю вашему вниманию перевод статьи &quot;Anatomy of Channels in Go&quot; автора Uday Hiwarale. Что такое каналы? Канал &mdash; это объект связи, с помощью...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F490336\\\u002F#post-content-body\",\"about\":[\"h_go\",\"f_develop\"],\"image\":[\"https:\\\u002F\\\u002Fhabr.com\\\u002Fshare\\\u002Fpublication\\\u002F490336\\\u002Fc3baa6d7e4776d1acd4196a4a9814462\\\u002F\"]}","metaDescription":"Привет, Хабр! Представляю вашему вниманию перевод статьи &quot;Anatomy of Channels in Go&quot; автора Uday Hiwarale.\r\nЧто такое каналы?\r\nКанал — это объект связи, с помощью которого горутины...","mainImageUrl":null,"amp":false,"customTrackerLinks":[]},"polls":[],"commentsEnabled":true,"rulesRemindEnabled":false,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"hasPinnedComments":true,"isEditorial":false}},"articlesIds":{},"isLoading":false,"pagesCount":{},"route":{},"reasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"karma":{}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"career":{"seoLandings":[{"title":"Go разработчик","vacanciesCount":125,"itemUrl":"https:\u002F\u002Fcareer.habr.com\u002Fvacancies\u002Fgo_razrabotchik","itemHubs":["go"]}],"hubs":"go"},"comments":{"articleComments":{},"searchCommentsResults":null,"previewComment":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":""}},"companies":{"companyRefs":{},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"vacancies":{},"workplaceInfo":null},"companyAdmin":{"companyInfo":null,"companyInfoLoading":false,"faqArticles":null,"brandingPreviewImageUrl":null,"jivoStatus":0},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"unreadCount":0,"pagesCount":0},"desktopState":{"desktopFl":null,"desktopHl":null,"isChecked":false,"isLoginDemanded":false},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":"true"},"flows":{"flows":[{"alias":"develop","id":1,"route":{"name":"FLOW_PAGE","params":{"flowName":"develop"}}},{"alias":"admin","id":6,"route":{"name":"FLOW_PAGE","params":{"flowName":"admin"}}},{"alias":"design","id":2,"route":{"name":"FLOW_PAGE","params":{"flowName":"design"}}},{"alias":"management","id":3,"route":{"name":"FLOW_PAGE","params":{"flowName":"management"}}},{"alias":"marketing","id":4,"route":{"name":"FLOW_PAGE","params":{"flowName":"marketing"}}},{"alias":"popsci","id":7,"route":{"name":"FLOW_PAGE","params":{"flowName":"popsci"}}}]},"global":{"isPwa":false,"device":"desktop","isHabrCom":true},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"infoPage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":null,"query":{},"pathname":null,"path":null,"href":""},"searchQuery":null},"me":{"user":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"pinnedPost":{"pinnedPost":null},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{"tasks":"project-block-article"}},"promoData":{"isLoading":false,"hasLoaded":false,"featurer":null,"megaposts":null,"promoLinks":null,"promoPosts":null},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"search":{"searchQueryError":null},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":[],"similarListRefs":null},"ssr":{"error":null,"isDataLoaded":false,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"technotext":{"nominationsList":[]},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"users":{"authorRefs":{},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"userSpecialization":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"items":{},"pagesCache":{},"markedViewedSilently":{},"markedRead":{},"unreadCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null},"unviewedCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
<script src="https://assets.habr.com/habr-web/js/chunk-vendors.59c14c8d.js" defer></script><script src="https://assets.habr.com/habr-web/js/app.af68bd55.js" defer></script>



    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-726094-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    </script>
  
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(24049213, "init", {
      defer:true,
      trackLinks:true,
      accurateTrackBounce:true,
      webvisor:false,
    });
  </script>
  <noscript>
    <div>
      <img src="https://mc.yandex.ru/watch/24049213" style="position:absolute; left:-9999px;" alt="" />
    </div>
  </noscript>
  
    <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
  
<script src="/js/ads.js" onload="window['zhY4i4nJ9K'] = true"></script>
</body>
</html>
